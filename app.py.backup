from flask import Flask, render_template, request, redirect, url_for, flash, jsonify, session, send_from_directory, make_response, send_file
from flask_mail import Mail, Message
from flask_login import LoginManager, UserMixin, login_user, login_required, logout_user, current_user
from werkzeug.security import generate_password_hash, check_password_hash
import firebase_admin
from firebase_admin import credentials, db, auth, firestore, storage
from config import Config
import json
from datetime import datetime, timedelta
from functools import wraps
from werkzeug.utils import secure_filename
import os
import base64
from dotenv import load_dotenv
from models.email_service import EmailService
import pytz
import requests
from PIL import Image
from io import BytesIO
from utils import register_filters
from routes.user_routes import user_routes
import io
import mimetypes
import uuid

try:
    from dotenv import load_dotenv
except ImportError:
    print("Warning: python-dotenv not installed. Please install it using: pip install python-dotenv")
    def load_dotenv(): pass

load_dotenv()  # Add this before creating the Flask app

# Load environment variables
load_dotenv()

# Initialize Flask app
app = Flask(__name__)

# Configure app based on environment
if os.environ.get('FLASK_ENV') == 'production':
    app.config.update(
        SECRET_KEY=os.environ.get('SECRET_KEY', 'your-secret-key'),
        SESSION_COOKIE_SECURE=True,
        REMEMBER_COOKIE_SECURE=True,
        SESSION_COOKIE_HTTPONLY=True,
        REMEMBER_COOKIE_HTTPONLY=True,
        SESSION_COOKIE_SAMESITE='Lax'
    )
else:
    app.config['SECRET_KEY'] = 'development-key'

# Register blueprints
app.register_blueprint(user_routes)

# Register Jinja2 filters
register_filters(app)

# Initialize Firebase Admin SDK
try:
    if os.environ.get('FIREBASE_CREDENTIALS'):
        # In production, use credentials from environment variable
        cred_dict = json.loads(os.environ.get('FIREBASE_CREDENTIALS'))
        cred = credentials.Certificate(cred_dict)
        print("Using Firebase credentials from environment variable")
    else:
        # In development, use service account file
        cred = credentials.Certificate('serviceAccountKey.json')
        print("Using Firebase credentials from serviceAccountKey.json")
    
    # Get Firebase API key from .env file
    firebase_api_key = os.environ.get('FIREBASE_API_KEY')
    if not firebase_api_key:
        print("Warning: FIREBASE_API_KEY not found in environment variables")
    else:
        print(f"Using Firebase API key from environment variables")
    
    # Initialize Firebase with options from serviceAccountKey.json
    firebase_options = {
        'databaseURL': 'https://giir-66ae6-default-rtdb.firebaseio.com',
        'storageBucket': 'giir-66ae6.appspot.com', 
        'apiKey': firebase_api_key  # Use API key from .env
    }
    
    # Initialize the Firebase app
    firebase_admin.initialize_app(cred, firebase_options)
    
    # Store Firebase config in app.config for easier access later
    app.config['FIREBASE_CONFIG'] = {
        'apiKey': firebase_api_key,
        'authDomain': 'giir-66ae6.firebaseapp.com',
        'databaseURL': 'https://giir-66ae6-default-rtdb.firebaseio.com',
        'projectId': 'giir-66ae6',
        'storageBucket': 'giir-66ae6.appspot.com',
    }
    
    print("Firebase initialized successfully")
except Exception as e:
    print(f"Error initializing Firebase: {str(e)}")
    raise

# Initialize Flask-Login
login_manager = LoginManager()
login_manager.init_app(app)
login_manager.login_view = 'login'

# Initialize Flask-Mail
mail = Mail(app)

# After initializing mail
email_service = EmailService(mail)

# Add datetime filter for Jinja templates
@app.template_filter('datetime')
def format_datetime(value):
    if isinstance(value, str):
        try:
            dt = datetime.fromisoformat(value)
        except ValueError:
            return value
    else:
        dt = value
    return dt.strftime('%B %d, %Y %I:%M %p')

# Add timezone formatting helper
def format_datetime_with_timezone(date_str, time_str, timezone_str):
    """Format datetime with timezone for consistent display"""
    try:
        # Create datetime object
        dt = datetime.strptime(f"{date_str} {time_str}", "%Y-%m-%d %H:%M")
        
        # Get timezone
        tz = pytz.timezone(timezone_str)
        
        # Localize the datetime
        local_dt = tz.localize(dt)
        
        return local_dt.isoformat()
    except Exception as e:
        print(f"Error formatting datetime: {str(e)}")
        return None

# Add this after app initialization but before routes
@app.template_filter('format_date')
def format_date(date_str):
    try:
        if isinstance(date_str, str):
            date = datetime.fromisoformat(date_str.replace('Z', '+00:00'))
        else:
            date = date_str
        return date.strftime('%B %d, %Y %I:%M %p')
    except Exception:
        return date_str  # Return original string if parsing fails

# Add this configuration after other app configurations
app.config['UPLOAD_FOLDER'] = 'static/uploads/documents'
app.config['MAX_CONTENT_LENGTH'] = 200 * 1024 * 1024  # 200MB max file size
ALLOWED_EXTENSIONS = {'pdf', 'doc', 'docx', 'xls', 'xlsx', 'ppt', 'pptx', 'zip'}

# Add these constants near the top of the file
ALLOWED_IMAGE_EXTENSIONS = {'png', 'jpg', 'jpeg', 'gif', 'webp', 'svg', 'bmp', 'ico', 'tiff', 'tif'}
DEFAULT_THEME = {
    'primary_color': '#007bff',
    'secondary_color': '#6c757d',
    'accent_color': '#28a745',
    'text_color': '#333333',
    'background_color': '#ffffff',
    'header_background': '#f8f9fa',
    'footer_background': '#343a40',
    'hero_text_color': '#ffffff',
    'font_family': "'Roboto', sans-serif",
    'heading_font': "'Poppins', sans-serif"
}

# Add this near the top with other upload folder configurations
app.config['COMMITTEE_UPLOAD_FOLDER'] = 'static/uploads/committee'

# Update or add these configuration settings
app.config['FIREBASE_API_KEY'] = os.environ.get('FIREBASE_API_KEY')

def allowed_file(filename):
    return '.' in filename and filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS

def allowed_image_file(filename):
    return '.' in filename and \
           filename.rsplit('.', 1)[1].lower() in ALLOWED_IMAGE_EXTENSIONS

def validate_associate_data(name, description, logo_url):
    """Validate associate data fields"""
    if not name or not name.strip():
        raise ValueError("Associate name is required")
    if not description or not description.strip():
        raise ValueError("Associate description is required")
    if not logo_url or not logo_url.strip():
        raise ValueError("Associate logo is required")
    return True

def compress_image(file, max_size_kb=500):
    """Compress image to reduce file size while maintaining quality"""
    try:
        # Read the image file
        if hasattr(file, 'read'):
            file.seek(0)  # Reset file pointer
            image_data = file.read()
            img = Image.open(BytesIO(image_data))
        else:
            img = Image.open(file)

        # Convert to RGB if necessary
        if img.mode in ('RGBA', 'P'):
            img = img.convert('RGB')

        # Initial quality
        quality = 95
        output = BytesIO()

        # Save with initial quality
        img.save(output, format='JPEG', quality=quality, optimize=True)
        
        # Binary search for optimal quality
        while output.tell() > max_size_kb * 1024 and quality > 10:
            output = BytesIO()
            quality = max(quality - 5, 10)
            img.save(output, format='JPEG', quality=quality, optimize=True)

        output.seek(0)
        return output.getvalue()

    except Exception as e:
        print(f"Error compressing image: {str(e)}")
        # If compression fails, return original file data
        file.seek(0)
        return file.read()

def validate_image(file, image_type='default'):
    """Validate image file based on type (hero or associate)"""
    if not file or not file.filename:
        raise ValueError("No file provided")

    if not allowed_image_file(file.filename):
        raise ValueError("Invalid file type. Only JPG, JPEG, PNG and GIF files are allowed")

    # Read image to validate dimensions
    try:
        img = Image.open(file)
        width, height = img.size
        
        # Different size limits for different image types
        if image_type == 'hero':
            if width > 4000 or height > 4000:
                raise ValueError("Hero image dimensions must be less than 4000x4000 pixels")
        elif image_type == 'associate':
            if width > 1000 or height > 1000:
                raise ValueError("Associate logo dimensions must be less than 1000x1000 pixels")
        else:
            if width > 2000 or height > 2000:
                raise ValueError("Image dimensions must be less than 2000x2000 pixels")
        
        file.seek(0)  # Reset file pointer after reading
        return True
    except Exception as e:
        raise ValueError(f"Invalid image: {str(e)}")

def save_associate_logo(logo_file, existing_logo=None):
    """Save associate logo to Firebase Storage and return the public URL"""
    if not logo_file or not logo_file.filename:
        if existing_logo:
            return existing_logo
        raise ValueError("Logo file is required")
    
    try:
        # Validate image with associate type
        validate_image(logo_file, image_type='associate')
        
        # Initialize Firebase Storage bucket
        bucket = storage.bucket()
        
        # Generate unique filename with original extension
        original_filename = secure_filename(logo_file.filename)
        ext = os.path.splitext(original_filename)[1].lower()
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        unique_id = str(uuid.uuid4())[:8]
        
        # Use dedicated path for associates
        unique_filename = f"content/associates/{timestamp}_{unique_id}{ext}"
        
        # Create a new blob
        blob = bucket.blob(unique_filename)
        
        # Set content type based on file extension
        content_type = mimetypes.guess_type(original_filename)[0] or 'image/jpeg'
        blob.content_type = content_type
        
        # Set metadata for optimization status
        metadata = {
            'optimized': 'false',
            'originalName': original_filename,
            'timestamp': timestamp,
            'type': 'associate_logo'  # Add type to distinguish from hero images
        }
        blob.metadata = metadata
        
        # Compress image if needed
        logo_file.seek(0)  # Reset file pointer
        img_data = compress_image(logo_file, max_size_kb=300)  # Smaller size for logos
        
        # Log the upload process
        print(f"Uploading logo: {unique_filename} with content type: {content_type}")
        
        # Upload the file with metadata
        blob.upload_from_string(
            img_data,
            content_type=content_type
        )
        
        # Make the blob publicly accessible
        blob.make_public()
        
        # Set cache control
        blob.cache_control = 'public, max-age=31536000'  # Cache for 1 year
        blob.patch()
        
        # Log successful upload
        print(f"Successfully uploaded logo: {unique_filename} to {blob.public_url}")
        
        return blob.public_url
        
    except Exception as e:
        print(f"Error saving logo to Firebase Storage: {str(e)}")
        raise ValueError(f"Error saving logo: {str(e)}")

def process_associates_data(request_form, request_files):
    """Process associates data from the form submission"""
    try:
        print("Received files in process_associates_data:", request_files.keys())
        associates = []
        errors = []
        bucket = storage.bucket()

        # Process existing associates
        existing_ids = request_form.getlist('existing_associate_ids[]')
        existing_logos = request_form.getlist('existing_associate_logos[]')
        
        print(f"Processing {len(existing_ids)} existing associates")
        
        # Check total number of associates (existing + new)
        new_files = request_files.getlist('new_associate_logos')
        total_associates = len(existing_ids) + len(new_files)
        MAX_ASSOCIATES = 10  # Maximum number of associates allowed
        
        if total_associates > MAX_ASSOCIATES:
            raise ValueError(f"Maximum number of associates ({MAX_ASSOCIATES}) exceeded. Please remove some logos before adding new ones.")
        
        # Handle existing associates
        for i, associate_id in enumerate(existing_ids):
            try:
                logo_url = existing_logos[i]
                logo_key = f'associate_logo_{associate_id}'
                
                if logo_key in request_files and request_files[logo_key].filename:
                    # Delete old logo if it exists
                    try:
                        if logo_url and logo_url.startswith('https://'):
                            blob_path = logo_url.split('/o/')[1].split('?')[0]
                            blob_path = blob_path.replace('%2F', '/')
                            blob = bucket.blob(blob_path)
                            if blob.exists():
                                blob.delete()
                                print(f"Successfully deleted old logo: {blob_path}")
                    except Exception as e:
                        print(f"Error deleting old logo: {str(e)}")

                    # Save new logo
                    logo_url = save_associate_logo(request_files[logo_key])
                
                associates.append({
                    'id': associate_id,
                    'logo': logo_url,
                    'name': 'Associate',
                    'description': ''
                })
                
            except Exception as e:
                errors.append(f"Error processing associate {associate_id}: {str(e)}")

        # Process new associate logos from multiple file upload
        if 'new_associate_logos' in request_files:
            new_files = request_files.getlist('new_associate_logos')
            print(f"Processing {len(new_files)} new associate logos")
            
            for file in new_files:
                if file and file.filename:
                    try:
                        logo_url = save_associate_logo(file)
                        associates.append({
                            'id': str(uuid.uuid4()),
                            'logo': logo_url,
                            'name': 'New Associate',
                            'description': ''
                        })
                        print(f"Successfully added new associate logo: {logo_url}")
                    except Exception as e:
                        print(f"Error processing new logo: {str(e)}")
                        errors.append(str(e))

        if errors:
            print("Errors during associate processing:", errors)
            raise Exception('\n'.join(errors))

        print(f"Successfully processed {len(associates)} total associates")
        return associates

    except Exception as e:
        print(f"Error in process_associates_data: {str(e)}")
        raise e

class User(UserMixin):
    def __init__(self, uid, email, full_name, is_admin=False):
        self.id = uid
        self.email = email
        self.full_name = full_name
        self.is_admin = is_admin

@login_manager.user_loader
def load_user(user_id):
    try:
        user = auth.get_user(user_id)
        # Get additional user data from Realtime Database
        ref = db.reference(f'users/{user_id}')
        user_data = ref.get()
        is_admin = user_data.get('is_admin', False) if user_data else False
        return User(user.uid, user.email, user.display_name, is_admin)
    except:
        return None

def send_confirmation_email(registration_data):
    return email_service.send_registration_confirmation(registration_data)

# Add this helper function near the top of the file
def get_site_design():
    """Helper function to fetch site design settings"""
    try:
        design_ref = db.reference('site_design')
        return design_ref.get() or DEFAULT_THEME
    except Exception as e:
        print(f"Error fetching site design: {str(e)}")
        return DEFAULT_THEME

@app.route('/')
def home():
    try:
        # Get home content from Firebase
        content_ref = db.reference('home_content')
        home_content = content_ref.get() or {
            'welcome': {
                'title': 'Welcome to GIIR Conference 2024',
                'subtitle': 'Global Institute on Innovative Research',
                'conference_date': 'International Conference 2024',
                'message': 'Join us for the premier conference in innovative research'
            },
            'hero': {
                'images': [],
                'conference': {
                    'name': 'GIIR Conference 2024',
                    'date': 'TBA',
                    'time': 'TBA',
                    'city': 'TBA',
                    'highlights': 'Keynote Speakers\nTechnical Sessions\nWorkshops\nNetworking Events'
                }
            }
        }
        
        site_design = get_site_design()
        
        return render_template('user/home.html', 
                            home_content=home_content,
                            site_design=site_design,
                            page_name='home')
    except Exception as e:
        print(f"Error loading home content: {str(e)}")
        return render_template('user/home.html', 
                            home_content={
                                'welcome': {
                                    'title': 'Welcome to GIIR Conference 2024',
                                    'subtitle': 'Global Institute on Innovative Research',
                                    'conference_date': 'International Conference 2024',
                                    'message': 'Join us for the premier conference in innovative research'
                                }
                            },
                            site_design=DEFAULT_THEME,
                            page_name='home')

@app.route('/about')
def about():
    try:
        # Get about content from Firebase Realtime Database
        about_ref = db.reference('about_content')
        about_content = about_ref.get() or {
            'overview': {
                'title': 'About GIIR Conference',
                'description': 'The Global Institute on Innovative Research (GIIR) Conference 2024 brings together leading researchers, practitioners, and industry experts from around the world.',
                'stats': {
                    'attendees': '500+',
                    'countries': '50+',
                    'papers': '200+',
                    'speakers': '30+'
                }
            },
            'objectives': [
                {
                    'icon': 'fa-lightbulb',
                    'title': 'Knowledge Exchange',
                    'description': 'Facilitate the exchange of innovative ideas and research findings'
                },
                {
                    'icon': 'fa-users',
                    'title': 'Networking',
                    'description': 'Create opportunities for networking and collaboration'
                },
                {
                    'icon': 'fa-chart-line',
                    'title': 'Research Impact',
                    'description': 'Showcase cutting-edge research and its potential impact'
                }
            ],
            'committee': [
                {
                    'role': 'Conference Chair',
                    'name': 'Prof. Sarah Johnson',
                    'affiliation': 'Stanford University, USA',
                    'expertise': ['Artificial Intelligence', 'Machine Learning']
                }
            ],
            'past_conferences': [
                {
                    'year': '2023',
                    'location': 'Tokyo, Japan',
                    'highlight': '450+ Attendees'
                }
            ]
        }
        
        return render_template('user/about.html', about_content=about_content, site_design=get_site_design())
    except Exception as e:
        flash(f'Error loading about content: {str(e)}', 'error')
        return render_template('user/about.html', about_content={
            'overview': {
                'title': 'About GIIR Conference',
                'description': 'The Global Institute on Innovative Research (GIIR) Conference 2024 brings together leading researchers, practitioners, and industry experts from around the world.',
                'stats': {
                    'attendees': '500+',
                    'countries': '50+',
                    'papers': '200+',
                    'speakers': '30+'
                }
            }
        }, site_design=get_site_design())

@app.route('/call-for-papers')
def call_for_papers():
    # Get call for papers content from Firebase
    cfp_content = db.reference('call_for_papers_content').get() or {}
    
    print(f"DEBUG - User CFP - Content from database: {cfp_content}")
    
    # Set up default values if they don't exist in the fetched data
    if 'cta' not in cfp_content:
        cfp_content['cta'] = {
            'submit_button_text': 'Submit Your Paper',
            'template_button_text': 'Download Template',
            'template_url': '#'
        }
        
    # Ensure other required sections exist with default values
    if 'topics_intro' not in cfp_content:
        cfp_content['topics_intro'] = 'We invite high-quality original research papers in the following areas (but not limited to):'
    
    if 'topics' not in cfp_content:
        print("DEBUG - User CFP - No topics found, using defaults")
        cfp_content['topics'] = [
            {
                'title': 'Artificial Intelligence & Machine Learning',
                'subtopics': ['Deep Learning and Neural Networks', 'Natural Language Processing', 'Computer Vision and Pattern Recognition', 'Reinforcement Learning', 'AI Ethics and Fairness']
            },
            {
                'title': 'Data Science & Analytics',
                'subtopics': ['Big Data Analytics', 'Predictive Analytics', 'Data Mining', 'Business Intelligence', 'Statistical Analysis']
            }
        ]
    else:
        print(f"DEBUG - User CFP - Topics from database: {cfp_content['topics']}")
    
    if 'important_dates' not in cfp_content:
        cfp_content['important_dates'] = [
            {
                'icon': 'fas fa-paper-plane',
                'title': 'Paper Submission',
                'date': 'March 15, 2024',
                'time': '23:59 GMT'
            },
            {
                'icon': 'fas fa-envelope-open-text',
                'title': 'Notification of Acceptance',
                'date': 'April 30, 2024',
                'time': '23:59 GMT'
            }
        ]
    
    if 'submission_guidelines' not in cfp_content:
        cfp_content['submission_guidelines'] = [
            {
                'title': 'Paper Format',
                'guideline_items': ['Papers must be written in English', 'Maximum length: 8 pages including figures and references']
            },
            {
                'title': 'Review Process',
                'guideline_items': ['Double-blind peer review', 'Minimum three reviewers per paper']
            }
        ]
    else:
        # Convert any guideline dictionaries to objects with proper properties to avoid the items() method conflict
        structured_guidelines = []
        for guideline in cfp_content['submission_guidelines']:
            if isinstance(guideline, dict):
                guideline_obj = {}
                
                # Copy all properties except 'items'
                for key, value in guideline.items():
                    if key != 'items':
                        guideline_obj[key] = value
                
                # Add 'guideline_items' property instead of 'items' to avoid the method name conflict
                if 'items' in guideline and isinstance(guideline['items'], list):
                    guideline_obj['guideline_items'] = guideline['items']
                else:
                    guideline_obj['guideline_items'] = []
                
                structured_guidelines.append(guideline_obj)
            else:
                # If it's not a dict, create a basic structure
                structured_guidelines.append({
                    'title': 'Guideline',
                    'guideline_items': []
                })
                
        cfp_content['submission_guidelines'] = structured_guidelines
    
    return render_template('user/call_for_papers.html', site_design=get_site_design(), cfp_content=cfp_content)

@app.route('/paper-submission', methods=['GET', 'POST'])
@login_required
def paper_submission():
    if request.method == 'POST':
        try:
            # Get form data
            paper_data = {
                'user_id': current_user.id,
                'user_email': current_user.email,
                'paper_title': request.form.get('paper_title'),
                'paper_abstract': request.form.get('paper_abstract'),
                'presentation_type': request.form.get('presentation_type'),
                'research_area': request.form.get('research_area'),
                'keywords': [k.strip() for k in request.form.get('keywords', '').split(',') if k.strip()],
                'submitted_at': datetime.now().isoformat(),
                'status': 'pending',
                'authors': [],
                'review_comments': '',
                'reviewed_by': '',
                'updated_at': datetime.now().isoformat()
            }

            # Process authors
            author_count = 0
            while f'authors[{author_count}][name]' in request.form:
                author = {
                    'name': request.form.get(f'authors[{author_count}][name]'),
                    'email': request.form.get(f'authors[{author_count}][email]'),
                    'institution': request.form.get(f'authors[{author_count}][institution]')
                }
                if all(author.values()):  # Only add if all fields are filled
                    paper_data['authors'].append(author)
                author_count += 1

            # Validate required fields
            required_fields = ['paper_title', 'paper_abstract', 'presentation_type', 'research_area']
            for field in required_fields:
                if not paper_data.get(field):
                    flash(f'Please fill in all required fields.', 'error')
                    return redirect(url_for('paper_submission'))

            if not paper_data['authors']:
                flash('At least one author is required.', 'error')
                return redirect(url_for('paper_submission'))

            # Handle paper file upload
            if 'paper_file' not in request.files:
                flash('Please upload a paper file.', 'error')
                return redirect(url_for('paper_submission'))

            file = request.files['paper_file']
            if not file or not file.filename:
                flash('Please select a paper file.', 'error')
                return redirect(url_for('paper_submission'))

            if not file.filename.lower().endswith('.pdf'):
                flash('Only PDF files are allowed.', 'error')
                return redirect(url_for('paper_submission'))

            # Read and encode file data
            file_data = file.read()
            file_base64 = base64.b64encode(file_data).decode('utf-8')

            # Add file data to paper_data
            paper_data.update({
                'file_data': file_base64,
                'file_name': secure_filename(file.filename),
                'file_type': file.content_type,
                'file_size': len(file_data)
            })

            # Debug print before saving
            print("Saving paper data:", {k: v for k, v in paper_data.items() if k != 'file_data'})

            # Store paper in Firebase
            papers_ref = db.reference('papers')
            new_paper = papers_ref.push(paper_data)
            paper_id = new_paper.key

            # Debug print after saving
            print("Paper saved with ID:", paper_id)

            # Send confirmation email
            try:
                email_service.send_paper_confirmation({
                    'authors': paper_data['authors'],
                    'paper_title': paper_data['paper_title'],
                    'presentation_type': paper_data['presentation_type'],
                    'paper_id': paper_id,
                    'user_email': current_user.email
                })
            except Exception as e:
                print(f"Error sending confirmation email: {str(e)}")

            flash('Paper submitted successfully! Check your email for confirmation.', 'success')
            return redirect(url_for('dashboard'))
            
        except Exception as e:
            print(f"Error submitting paper: {str(e)}")  # Log the error
            flash(f'Error submitting paper: {str(e)}', 'error')
            return redirect(url_for('paper_submission'))

    return render_template('user/papers/submit.html', 
                         site_design=get_site_design())

@app.route('/author-guidelines')
def author_guidelines():
    try:
        # Get guidelines from Firebase
        guidelines_ref = db.reference('author_guidelines')
        guidelines = guidelines_ref.get() or {}
        
        return render_template('user/papers/guidelines.html', 
                             guidelines=guidelines,
                             site_design=get_site_design())
    except Exception as e:
        flash('Error loading author guidelines.', 'error')
        return redirect(url_for('home'))

@app.route('/venue')
def venue():
    # Get the venue data from Firebase
    venue_content = {}
    try:
        venue_ref = firestore.client().collection('content').document('venue')
        venue_doc = venue_ref.get()
        if venue_doc.exists:
            venue_content = venue_doc.to_dict()
    except Exception as e:
        print(f"Error getting venue content: {str(e)}")
        
    return render_template('user/venue.html', venue_content=venue_content)

@app.route('/guest-speakers')
def guest_speakers():
    # In the future, this data could come from Firebase
    # For now, we're using static placeholder data
    return render_template('user/guest_speakers.html', site_design=get_site_design())

@app.route('/video-conference')
def video_conference():
    return render_template('user/video_conference.html')

@app.route('/profile')
@login_required
def profile():
    return render_template('user/account/profile.html')

@app.route('/login', methods=['GET', 'POST'])
def login():
    if request.method == 'POST':
        email = request.form.get('email')
        password = request.form.get('password')
        try:
            # Instead of trying to validate the login via REST API, we'll use Firebase Admin SDK
            # to retrieve the user, and if found, we'll assume the login is correct for now
            # This is a temporary workaround until we can fix the API key issue
            
            try:
                # Check if the user exists
                user = auth.get_user_by_email(email)
                
                # Since we can't verify the password directly with the admin SDK, 
                # we'll just check if this is our known admin user
                if email == "admin@giirconference.com" and password == "Admin@2024!":
                    # Get user data from Realtime Database
                    ref = db.reference(f'users/{user.uid}')
                    user_data = ref.get()
                    
                    if not user_data:
                        # If user data doesn't exist in Realtime DB, create it
                        user_data = {
                            'email': email,
                            'full_name': user.display_name or email.split('@')[0],
                            'created_at': datetime.now().isoformat(),
                            'is_admin': True,  # Set as admin since we're using the admin credentials
                            'last_login': datetime.now().isoformat()
                        }
                        ref.set(user_data)
                    else:
                        # Update last login time
                        ref.update({
                            'last_login': datetime.now().isoformat()
                        })
                    
                    is_admin = user_data.get('is_admin', True)  # Default to True for admin account
                    display_name = user_data.get('full_name', email.split('@')[0])
                    
                    # Create User object and login
                    user_obj = User(user.uid, email, display_name, is_admin)
                    login_user(user_obj)
                    
                    flash('Logged in successfully!', 'success')
                    
                    # Check if there's a registration selection in session
                    if 'registration_type' in session and 'registration_period' in session:
                        reg_type = session.pop('registration_type')
                        reg_period = session.pop('registration_period')
                        return redirect(url_for('registration_form', type=reg_type, period=reg_period))
                    
                    # Check for next parameter
                    next_page = request.args.get('next')
                    if next_page:
                        return redirect(next_page)
                    
                    # Redirect admin users to admin dashboard
                    if is_admin:
                        return redirect(url_for('admin_dashboard'))
                    return redirect(url_for('dashboard'))
                else:
                    print("Password doesn't match for admin account")
                    flash('Invalid email or password', 'error')
                    return render_template('user/auth/login.html', site_design=get_site_design())
                    
            except auth.UserNotFoundError:
                print(f"User with email {email} not found")
                flash('Invalid email or password', 'error')
                return render_template('user/auth/login.html', site_design=get_site_design())
                
        except Exception as e:
            print(f"Login error: {str(e)}")
            flash('Login error occurred', 'error')
            
    return render_template('user/auth/login.html', site_design=get_site_design())

@app.route('/register', methods=['GET', 'POST'])
def register_account():
    if request.method == 'POST':
        email = request.form.get('email')
        password = request.form.get('password')
        confirm_password = request.form.get('confirm_password')
        full_name = request.form.get('full_name')
        terms = request.form.get('terms')

        if not terms:
            flash('You must accept the terms and conditions.', 'error')
            return render_template('user/register.html', site_design=get_site_design())

        if password != confirm_password:
            flash('Passwords do not match.', 'error')
            return render_template('user/register.html', site_design=get_site_design())

        try:
            # Create user in Firebase Authentication
            user = auth.create_user(
                email=email,
                password=password,
                display_name=full_name
            )
            
            # User data for database and email
            user_data = {
                'email': email,
                'full_name': full_name,
                'created_at': datetime.now().isoformat(),
                'is_admin': False  # Default to normal user
            }
            
            # Store additional user data in Realtime Database
            ref = db.reference('users')
            ref.child(user.uid).set(user_data)
            
            # Send welcome email
            email_service.send_welcome_email(user_data)
            
            flash('Account created successfully! Please check your email and login.', 'success')
            return redirect(url_for('login'))
        except Exception as e:
            flash(f'Error creating account: {str(e)}', 'error')
            return render_template('user/register.html', site_design=get_site_design())
    
    return render_template('user/register.html', site_design=get_site_design())

@app.route('/logout')
@login_required
def logout():
    logout_user()
    flash('Logged out successfully!', 'success')
    return redirect(url_for('home'))

@app.route('/registration')
def registration():
    try:
        # Get registration fees from Firebase
        fees_ref = db.reference('registration_fees')
        fees = fees_ref.get()
        
        return render_template('user/registration.html', 
                             site_design=get_site_design(),
                             fees=fees)
    except Exception as e:
        flash('Error loading registration fees.', 'error')
        return render_template('user/registration.html', 
                             site_design=get_site_design(),
                             fees={})

@app.route('/registration/register', methods=['POST'])
def registration_select():
    if not current_user.is_authenticated:
        # Store registration selection in session
        session['registration_type'] = request.form.get('registration_type')
        session['registration_period'] = request.form.get('registration_period')
        # Redirect to login with next parameter
        return redirect(url_for('login', next=url_for('registration_form')))
    
    # If user is already logged in, proceed to registration form
    return redirect(url_for('registration_form', 
                          type=request.form.get('registration_type'),
                          period=request.form.get('registration_period')))

@app.route('/dashboard')
@login_required
def dashboard():
    try:
        # Get user's registrations
        registrations_ref = db.reference('registrations')
        registrations = registrations_ref.order_by_child('user_id').equal_to(current_user.id).get()
        
        # Get registration fees for displaying amounts
        fees_ref = db.reference('registration_fees')
        fees = fees_ref.get()
        
        return render_template('user/dashboard.html', 
                             registrations=registrations or {}, 
                             fees=fees,
                             site_design=get_site_design())
    except Exception as e:
        flash(f'Error loading dashboard: {str(e)}', 'error')
        return render_template('user/dashboard.html', 
                             registrations={}, 
                             fees={},
                             site_design=get_site_design())

@app.route('/schedule')
def schedule():
    schedule_ref = db.reference('schedule')
    schedule = schedule_ref.get()
    return render_template('user/conference/schedule.html', schedule=schedule, site_design=get_site_design())

def admin_required(f):
    @wraps(f)
    def decorated_function(*args, **kwargs):
        if not current_user.is_authenticated or not current_user.is_admin:
            flash('You need administrator privileges to access this page.', 'error')
            return redirect(url_for('home'))
        return f(*args, **kwargs)
    return decorated_function

@app.route('/admin/dashboard')
@login_required
@admin_required
def admin_dashboard():
    try:
        # Get all users
        users_ref = db.reference('users')
        users = users_ref.get() or {}
        
        # Get all registrations
        reg_ref = db.reference('registrations')
        registrations = reg_ref.get() or {}
        
        # Get all submissions
        submissions_ref = db.reference('submissions')
        submissions = submissions_ref.get() or {}
        
        # Calculate stats
        stats = {
            'total_users': len(users) if users else 0,
            'total_registrations': len(registrations) if registrations else 0,
            'total_submissions': len(submissions) if submissions else 0,
            'pending_registrations': sum(1 for reg in registrations.values() if reg and reg.get('payment_status') == 'pending') if registrations else 0,
            'pending_submissions': sum(1 for sub in submissions.values() if sub and sub.get('status') == 'pending') if submissions else 0
        }
        
        # Get recent registrations and users (last 5)
        recent_registrations = {}
        recent_users = {}
        
        if registrations:
            # Sort registrations by created_at date
            sorted_registrations = sorted(
                [(k, v) for k, v in registrations.items() if v and v.get('created_at')],
                key=lambda x: x[1].get('created_at', ''),
                reverse=True
            )
            # Get first 5 items
            recent_registrations = dict(sorted_registrations[:5])
            
        if users:
            # Sort users by created_at date
            sorted_users = sorted(
                [(k, v) for k, v in users.items() if v and v.get('created_at')],
                key=lambda x: x[1].get('created_at', ''),
                reverse=True
            )
            # Get first 5 items
            recent_users = dict(sorted_users[:5])
        
        return render_template('admin/dashboard.html', 
                             users=recent_users, 
                             registrations=recent_registrations,
                             stats=stats,
                             site_design=get_site_design())
    except Exception as e:
        flash(f'Error loading admin dashboard: {str(e)}', 'error')
        return render_template('admin/dashboard.html', 
                             users={}, 
                             registrations={},
                             stats={
                                'total_users': 0,
                                'total_registrations': 0,
                                'total_submissions': 0,
                                'pending_registrations': 0,
                                'pending_submissions': 0
                             },
                             site_design=get_site_design())

@app.route('/admin/users')
@login_required
@admin_required
def admin_users():
    try:
        users_ref = db.reference('users')
        users = users_ref.get()
        return render_template('admin/users.html', users=users or {})
    except Exception as e:
        flash(f'Error loading users: {str(e)}', 'error')
        return render_template('admin/users.html', users={})

@app.route('/admin/toggle-admin/<user_id>', methods=['POST'])
@login_required
@admin_required
def toggle_admin(user_id):
    try:
        user_ref = db.reference(f'users/{user_id}')
        user_data = user_ref.get()
        if user_data:
            user_data['is_admin'] = not user_data.get('is_admin', False)
            user_ref.update({'is_admin': user_data['is_admin']})
            flash(f"Admin status updated successfully.", 'success')
        return redirect(url_for('admin_users'))
    except Exception as e:
        flash(f'Error updating admin status: {str(e)}', 'error')
        return redirect(url_for('admin_users'))

def create_admin_user():
    try:
        admin_email = "admin@giirconference.com"
        admin_password = "Admin@2024!"
        admin_name = "Conference Admin"

        # Try to get existing admin user
        try:
            user = auth.get_user_by_email(admin_email)
            # Update existing admin's password
            auth.update_user(
                user.uid,
                password=admin_password
            )
            print("Admin password updated successfully!")
        except auth.UserNotFoundError:
            # Create new admin user if doesn't exist
            user = auth.create_user(
                email=admin_email,
                password=admin_password,
                display_name=admin_name
            )
            print("New admin user created successfully!")

        # Update or create admin data in Realtime Database
        ref = db.reference('users')
        ref.child(user.uid).update({
            'email': admin_email,
            'full_name': admin_name,
            'created_at': datetime.now().isoformat(),
            'is_admin': True,
            'updated_at': datetime.now().isoformat()
        })

        print("Admin user configuration complete!")
        print(f"Email: {admin_email}")
        print(f"Password: {admin_password}")
        return True
    except Exception as e:
        print(f"Error configuring admin user: {str(e)}")
        return False

def create_second_admin_user():
    try:
        admin_email = "admin@giirconference.com"
        admin_password = "Admin@2024!"
        admin_name = "Secondary Admin"

        # Try to get existing user by email
        try:
            user = auth.get_user_by_email(admin_email)
            # Update existing user's password
            auth.update_user(
                user.uid,
                password=admin_password
            )
            print("Second admin password updated successfully!")
        except auth.UserNotFoundError:
            # Create new admin user if doesn't exist
            user = auth.create_user(
                email=admin_email,
                password=admin_password,
                display_name=admin_name
            )
            print("New second admin user created successfully!")

        # Update or create admin data in Realtime Database
        ref = db.reference('users')
        ref.child(user.uid).update({
            'email': admin_email,
            'full_name': admin_name,
            'created_at': datetime.now().isoformat(),
            'is_admin': True,
            'updated_at': datetime.now().isoformat()
        })

        print("Second admin user configuration complete!")
        print(f"Email: {admin_email}")
        print(f"Password: {admin_password}")
        return True
    except Exception as e:
        print(f"Error configuring second admin user: {str(e)}")
        return False

@app.route('/setup-second-admin')
def setup_second_admin():
    success = create_second_admin_user()
    if success:
        return "Second admin user created/updated successfully! Check server logs for details."
    else:
        return "Error creating second admin user. Check server logs for details."

@app.route('/admin/venue', methods=['GET', 'POST'])
@admin_required
def admin_venue():
    if request.method == 'POST':
        try:
            # Get and validate form data
            venue_data = {
                'name': request.form.get('name', '').strip(),
                'address': request.form.get('address', '').strip(),
                'city': request.form.get('city', '').strip(),
                'country': request.form.get('country', '').strip(),
                'postal_code': request.form.get('postal_code', '').strip(),
                'phone': request.form.get('phone', '').strip(),
                'email': request.form.get('email', '').strip(),
                'map_url': request.form.get('map_url', '').strip()
            }
            
            # Validate required fields
            required_fields = ['name', 'address', 'city', 'country', 'postal_code', 'phone', 'email']
            missing_fields = [field for field in required_fields if not venue_data.get(field)]
            
            if missing_fields:
                flash(f'Missing required fields: {", ".join(missing_fields)}', 'danger')
                return redirect(url_for('admin_venue'))
            
            # Validate email format
            if '@' not in venue_data['email']:
                flash('Invalid email format', 'danger')
                return redirect(url_for('admin_venue'))
            
            # Generate map URL if not provided or invalid
            if not venue_data['map_url'] or 'maps/embed' not in venue_data['map_url']:
                address = f"{venue_data['address']}, {venue_data['city']}, {venue_data['country']}"
                venue_data['map_url'] = f"https://www.google.com/maps/embed/v1/place?key={app.config.get('GOOGLE_MAPS_API_KEY', '')}&q={address}"
            
            # Update venue details in Firebase
            venue_ref = db.reference('venue_details')
            venue_ref.set(venue_data)
            
            flash('Venue details updated successfully', 'success')
            return redirect(url_for('admin_venue'))
            
        except Exception as e:
            print(f"Error updating venue details: {str(e)}")
            flash(f'Error updating venue details: {str(e)}', 'danger')
            return redirect(url_for('admin_venue'))
    
    try:
        # Get current venue details
        venue_ref = db.reference('venue_details')
        venue_details = venue_ref.get()
        
        return render_template('admin/admin_venue.html', 
                             site_design=get_site_design(), 
                             venue_details=venue_details)
    except Exception as e:
        print(f"Error loading venue details: {str(e)}")
        flash(f'Error loading venue details: {str(e)}', 'danger')
        return render_template('admin/admin_venue.html', 
                             site_design=get_site_design(), 
                             venue_details=None)

@app.route('/admin/registration-fees', methods=['GET', 'POST'])
@admin_required
def admin_registration_fees():
    if request.method == 'POST':
        try:
            # Debug: Print all form data
            print("Form data received:", request.form)
            
            # Get currency settings
            currency_code = request.form.get('currency_code')
            custom_currency_symbol = request.form.get('custom_currency_symbol') if currency_code == 'custom' else None
            
            # Set up the currency structure
            currency = {
                'code': currency_code,
                'symbol': custom_currency_symbol if currency_code == 'custom' else {
                    'ZAR': 'R',
                    'USD': '$',
                    'EUR': '€',
                    'GBP': '£',
                    'AUD': 'A$'
                }.get(currency_code)
            }
            
            # Convert form data to float where needed
            def get_float(key, default=0):
                value = request.form.get(key)
                try:
                    return float(value) if value and value.strip() else default
                except (ValueError, TypeError):
                    print(f"Error converting {key} to float. Value: {value}")
                    return default
            
            # Convert form data to int where needed
            def get_int(key, default=0):
                value = request.form.get(key)
                try:
                    return int(value) if value and value.strip() else default
                except (ValueError, TypeError):
                    print(f"Error converting {key} to int. Value: {value}")
                    return default
            
            registration_fees = {
                'currency': currency,
                'early_bird': {
                    'enabled': request.form.get('early_bird_enabled') == 'on',
                    'deadline': request.form.get('early_bird_deadline', ''),
                    'seats': {
                        'total': get_int('early_bird_total_seats', 100),
                        'remaining': get_int('early_bird_remaining_seats', 100),
                        'show_remaining': request.form.get('show_remaining_seats') == 'on'
                    },
                    'fees': {
                        'student_author': get_float('early_bird_student'),
                        'regular_author': get_float('early_bird_regular'),
                        'physical_delegate': get_float('early_bird_physical'),
                        'virtual_delegate': get_float('early_bird_virtual'),
                        'listener': get_float('early_bird_listener')
                    },
                    'benefits': [b for b in request.form.getlist('early_bird_benefits[]') if b and b.strip()]
                } if request.form.get('early_bird_enabled') == 'on' else None,
                'early': {
                    'deadline': request.form.get('early_deadline', ''),
                    'fees': {
                        'student_author': get_float('early_student'),
                        'regular_author': get_float('early_regular'),
                        'physical_delegate': get_float('early_physical'),
                        'virtual_delegate': get_float('early_virtual'),
                        'listener': get_float('early_listener')
                    },
                    'benefits': [b for b in request.form.getlist('early_benefits[]') if b and b.strip()]
                },
                'regular': {
                    'deadline': request.form.get('regular_deadline', ''),
                    'fees': {
                        'student_author': get_float('regular_student'),
                        'regular_author': get_float('regular_regular'),
                        'physical_delegate': get_float('regular_physical'),
                        'virtual_delegate': get_float('regular_virtual')
                    },
                    'benefits': [b for b in request.form.getlist('regular_benefits[]') if b and b.strip()]
                },
                'late': {
                    'deadline': request.form.get('late_deadline', ''),
                    'fees': {
                        'student_author': get_float('late_student'),
                        'regular_author': get_float('late_regular'),
                        'physical_delegate': get_float('late_physical'),
                        'virtual_delegate': get_float('late_virtual'),
                        'listener': get_float('late_listener')
                    },
                    'benefits': [b for b in request.form.getlist('late_benefits[]') if b and b.strip()]
                },
                'additional_items': {
                    'extra_paper': {
                        'enabled': request.form.get('extra_paper_enabled') == 'on',
                        'fee': get_float('extra_paper_fee'),
                        'description': request.form.get('extra_paper_description', '').strip()
                    },
                    'workshop': {
                        'enabled': request.form.get('workshop_enabled') == 'on',
                        'fee': get_float('workshop_fee'),
                        'description': request.form.get('workshop_description', '').strip()
                    },
                    'banquet': {
                        'enabled': request.form.get('banquet_enabled') == 'on',
                        'fee': get_float('banquet_fee'),
                        'description': request.form.get('banquet_description', '').strip(),
                        'virtual_eligible': request.form.get('banquet_virtual_eligible') == 'on'
                    }
                }
            }
            
            # Debug: Print the structured data
            print("Structured data to save:", registration_fees)
            
            # Update registration fees in Firebase
            db.reference('registration_fees').set(registration_fees)
            
            flash('Registration fees updated successfully', 'success')
            return redirect(url_for('admin_registration_fees'))
            
        except Exception as e:
            import traceback
            print("Error saving registration fees:")
            print(traceback.format_exc())  # Print full stack trace
            flash(f'Error updating registration fees: {str(e)}', 'danger')
            return redirect(url_for('admin_registration_fees'))
    
    try:
        # Get current fees settings
        fees_ref = db.reference('registration_fees')
        current_fees = fees_ref.get() or {}
        
        # Debug: Print current fees
        print("Current fees loaded:", current_fees)
        
        return render_template('admin/admin_registration_fees.html', 
                             site_design=get_site_design(), 
                             fees=current_fees)
    except Exception as e:
        import traceback
        print("Error loading registration fees:")
        print(traceback.format_exc())  # Print full stack trace
        flash(f'Error loading registration fees: {str(e)}', 'danger')
        return render_template('admin/admin_registration_fees.html', 
                             site_design=get_site_design(), 
                             fees={})

@app.route('/admin/downloads', methods=['GET', 'POST'])
@login_required
@admin_required
def admin_downloads():
    if request.method == 'POST':
        if 'file' not in request.files:
            flash('No file selected', 'error')
            return redirect(request.url)
            
        file = request.files['file']
        if file.filename == '':
            flash('No file selected', 'error')
            return redirect(request.url)
            
        if file and allowed_file(file.filename):
            try:
                # Create upload folder if it doesn't exist
                os.makedirs(app.config['UPLOAD_FOLDER'], exist_ok=True)
                
                # Secure the filename and generate unique name
                filename = secure_filename(file.filename)
                unique_filename = f"{datetime.now().strftime('%Y%m%d_%H%M%S')}_{filename}"
                file_path = os.path.join(app.config['UPLOAD_FOLDER'], unique_filename)
                
                # Save file locally
                file.save(file_path)
                
                # Get file size
                file_size = os.path.getsize(file_path)
                file_size_str = f"{file_size/1024:.1f} KB" if file_size < 1024*1024 else f"{file_size/(1024*1024):.1f} MB"
                
                # Store file information in Firebase
                downloads_ref = db.reference('downloads')
                new_download = {
                    'title': request.form.get('title'),
                    'description': request.form.get('description'),
                    'file_url': f"/static/uploads/documents/{unique_filename}",
                    'file_type': filename.rsplit('.', 1)[1].lower(),
                    'file_size': file_size_str,
                    'uploaded_at': datetime.now().isoformat(),
                    'type': request.form.get('type', 'pdf')  # Default to pdf if not specified
                }
                downloads_ref.push(new_download)
                
                flash('File uploaded successfully!', 'success')
                return redirect(url_for('admin_downloads'))
                
            except Exception as e:
                flash(f'Error uploading file: {str(e)}', 'error')
                return redirect(request.url)
        else:
            flash('Invalid file type', 'error')
            return redirect(request.url)
    
    # Get all downloads for display
    downloads_ref = db.reference('downloads')
    downloads = downloads_ref.get()
    return render_template('admin/downloads.html', site_design=get_site_design(), downloads=downloads)

@app.route('/admin/downloads/delete/<download_id>', methods=['POST'])
@login_required
@admin_required
def delete_download(download_id):
    try:
        # Get download info
        downloads_ref = db.reference(f'downloads/{download_id}')
        download = downloads_ref.get()
        
        if download:
            # Delete file from storage
            file_path = os.path.join(app.root_path, download['file_url'].lstrip('/'))
            if os.path.exists(file_path):
                os.remove(file_path)
            
            # Delete from Firebase
            downloads_ref.delete()
            
            flash('Download deleted successfully!', 'success')
        else:
            flash('Download not found', 'error')
            
    except Exception as e:
        flash(f'Error deleting download: {str(e)}', 'error')
        
    return redirect(url_for('admin_downloads'))

@app.route('/admin/registrations')
@login_required
@admin_required
def admin_registrations():
    try:
        # Get registrations from Firebase
        registrations_ref = db.reference('registrations')
        registrations_data = registrations_ref.get()
        
        # Convert to list and add the Firebase key as _id
        registrations = []
        if registrations_data:
            for key, reg in registrations_data.items():
                reg['_id'] = key  # Add Firebase key as _id
                # Ensure all required fields exist with defaults
                reg.setdefault('submission_date', '')
                reg.setdefault('full_name', '')
                reg.setdefault('email', '')
                reg.setdefault('institution', '')
                reg.setdefault('registration_type', '')
                reg.setdefault('registration_period', '')
                reg.setdefault('total_amount', 0)
                reg.setdefault('payment_status', 'pending')
                reg.setdefault('workshop', False)
                reg.setdefault('banquet', False)
                reg.setdefault('extra_paper', False)
                registrations.append(reg)
            
            # Sort by submission date (newest first)
            registrations.sort(key=lambda x: x.get('submission_date', ''), reverse=True)
        
        return render_template('admin/manage_registrations.html', 
                            registrations=registrations,
                            site_design=get_site_design())
                            
    except Exception as e:
        print(f"Error loading registrations: {str(e)}")
        flash(f'Error loading registrations: {str(e)}', 'danger')
        return render_template('admin/manage_registrations.html', 
                            registrations=[],
                            site_design=get_site_design())

@app.route('/admin/registrations/<registration_id>')
@login_required
@admin_required
def get_registration_details(registration_id):
    try:
        registration_ref = db.reference(f'registrations/{registration_id}')
        registration = registration_ref.get()
        
        if registration:
            # Update file paths to use the new /uploads route
            if registration.get('payment_proof'):
                registration['payment_proof'] = registration['payment_proof'].replace('/static/uploads/', '')
            if registration.get('paper') and registration['paper'].get('file_path'):
                registration['paper']['file_path'] = registration['paper']['file_path'].replace('/static/uploads/', '')
            
            return jsonify(registration)
        else:
            return jsonify({'error': 'Registration not found'}), 404
    except Exception as e:
        return jsonify({'error': str(e)}), 500

def get_email_template(template_name):
    """Get email template from Firebase or return default template"""
    try:
        templates_ref = db.reference('email_templates').child(template_name)
        template = templates_ref.get()
        if template:
            return template
    except Exception as e:
        print(f"Error fetching template: {e}")
    
    # Default templates if not found in Firebase
    default_templates = {
        'registration_approval': {
            'subject': 'Your Conference Registration Has Been Approved',
            'content': '''Dear {{full_name}},

We are pleased to inform you that your registration for the conference has been approved!

Registration Details:
- Type: {{registration_type}}
- Amount Paid: R {{amount_paid}}

The conference will be held on {{conference_dates}}. We will send you additional information about the schedule and venue details closer to the date.

Thank you for registering for our conference. We look forward to your participation!

Best regards,
Conference Team'''
        },
        'registration_rejection': {
            'subject': 'Conference Registration Status Update',
            'content': '''Dear {{full_name}},

We regret to inform you that your conference registration could not be approved at this time.

Reason: {{rejection_reason}}

If you believe this is an error or would like to discuss this further, please contact our support team at {{support_email}}.

Best regards,
Conference Team'''
        }
    }
    
    return default_templates.get(template_name)

def send_registration_email(registration, template_name, **kwargs):
    """Send email notification for registration status update"""
    try:
        template = get_email_template(template_name)
        if not template:
            raise ValueError(f"Email template '{template_name}' not found")
        
        # Prepare template variables
        template_vars = {
            'full_name': registration.get('full_name', ''),
            'registration_type': registration.get('registration_type', '').replace('_', ' ').title(),
            'amount_paid': registration.get('total_amount', '0'),
            'conference_dates': 'September 15-17, 2024',  # You should get this from your conference settings
            'support_email': 'support@conference.com',  # You should get this from your conference settings
            **kwargs
        }
        
        # Replace template variables
        content = template['content']
        for key, value in template_vars.items():
            content = content.replace('{{' + key + '}}', str(value))
        
        # Create and send email
        msg = Message(
            subject=template['subject'],
            recipients=[registration.get('email')],
            body=content
        )
        mail.send(msg)
        return True
    except Exception as e:
        print(f"Error sending email: {e}")
        return False

@app.route('/admin/registrations/<registration_id>/status', methods=['POST'])
@login_required
@admin_required
def update_registration_status(registration_id):
    try:
        data = request.get_json()
        status = data.get('status')
        rejection_reason = data.get('rejection_reason')
        send_email = data.get('send_email', False)
        
        if not status:
            return jsonify({'success': False, 'error': 'Status is required'}), 400
        
        # Get registration data
        registration_ref = db.reference(f'registrations/{registration_id}')
        registration_data = registration_ref.get()
        
        if not registration_data:
            return jsonify({'success': False, 'error': 'Registration not found'}), 404
        
        # Update status
        update_data = {
            'payment_status': status,
            'updated_at': datetime.now().isoformat(),
            'updated_by': current_user.email
        }
        
        if status == 'rejected' and rejection_reason:
            update_data['rejection_reason'] = rejection_reason
        
        registration_ref.update(update_data)
        
        email_sent = False
        if send_email:
            # Send email notification with correct template name
            template_name = 'registration_approval' if status == 'approved' else 'registration_rejection'
            email_sent = send_registration_email(
                registration_data,
                template_name,
                rejection_reason=rejection_reason
            )
        
        return jsonify({
            'success': True,
            'email_sent': email_sent
        })
        
    except Exception as e:
        print(f"Error updating registration status: {e}")
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/admin/registrations/<registration_id>/payment-proof')
@login_required
@admin_required
def get_payment_proof(registration_id):
    try:
        registration_ref = db.reference(f'registrations/{registration_id}')
        registration = registration_ref.get()
        
        if not registration:
            return jsonify({'error': 'Registration not found'}), 404
            
        if not registration.get('payment_proof'):
            return jsonify({'error': 'No payment proof uploaded'}), 404
            
        # Clean up the file path
        payment_proof = registration['payment_proof']
        if not payment_proof.startswith('payments/'):
            payment_proof = f'payments/{payment_proof}'
            
        return jsonify({'url': payment_proof})
    except Exception as e:
        return jsonify({'error': str(e)}), 500

@app.route('/admin/registrations/<registration_id>/notes', methods=['POST'])
@login_required
@admin_required
def save_registration_notes(registration_id):
    try:
        data = request.get_json()
        notes = data.get('notes', '').strip()
        
        registration_ref = db.reference(f'registrations/{registration_id}')
        registration_ref.update({
            'admin_notes': notes,
            'notes_updated_at': datetime.now().isoformat(),
            'notes_updated_by': current_user.id
        })
        
        return jsonify({'success': True})
    except Exception as e:
        return jsonify({'error': str(e)}), 500

def send_email(to, subject, body):
    """
    Helper function to send emails using Flask-Mail.
    
    Args:
        to (str): Recipient email address
        subject (str): Email subject
        body (str): Email body content
    """
    try:
        msg = Message(
            subject=subject,
            recipients=[to],
            body=body,
            sender=app.config['MAIL_DEFAULT_SENDER']
        )
        mail.send(msg)
        return True
    except Exception as e:
        print(f"Error sending email: {str(e)}")
        return False

def send_approval_email(email, registration):
    subject = "GIIR Conference 2024 - Registration Approved"
    body = f"""Dear {registration.get('full_name')},

Your registration for the GIIR Conference 2024 has been approved.

Registration Details:
- Type: {registration.get('registration_type', '').replace('_', ' ').title()}
- Period: {registration.get('registration_period', '').replace('_', ' ').title()}
- Total Amount: R {registration.get('total_amount')}

{'Your paper submission has been confirmed.' if 'author' in registration.get('registration_type', '') else ''}
{'Virtual access details will be sent closer to the conference date.' if 'virtual' in registration.get('registration_type', '') else ''}

Thank you for registering for GIIR Conference 2024.

Best regards,
GIIR Conference Team"""
    
    send_email(email, subject, body)

def send_rejection_email(email, registration):
    subject = "GIIR Conference 2024 - Registration Update"
    body = f"""Dear {registration.get('full_name')},

Your registration for the GIIR Conference 2024 requires attention.

Please log in to your dashboard to view the status of your registration and make any necessary updates.

If you have any questions, please contact us.

Best regards,
GIIR Conference Team"""
    
    send_email(email, subject, body)


@login_required
@admin_required
def update_submission_comments(submission_id):
    data = request.get_json()
    comments = data.get('comments')
    
    if comments is None:
        return jsonify({'success': False, 'error': 'Comments are required'}), 400
        
    try:
        # Update submission comments in Firebase
        submission_ref = db.reference(f'papers/{submission_id}')
        submission_ref.update({
            'review_comments': comments,
            'updated_at': datetime.utcnow().isoformat(),
            'reviewed_by': current_user.email
        })
        return jsonify({'success': True})
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500

def send_submission_status_email(email, paper_title, status, comments):
    subject = f'Update on your GIIR Conference Paper Submission'
    
    status_messages = {
        'accepted': 'We are pleased to inform you that your paper has been accepted.',
        'rejected': 'We regret to inform you that your paper was not accepted.',
        'revision': 'Your paper requires revisions before it can be accepted.'
    }
    
    body = f"""Dear Author,

This email is regarding your paper submission: "{paper_title}"

{status_messages.get(status, 'Your paper status has been updated.')}

Reviewer Comments:
{comments or 'No additional comments provided.'}

{'Please submit your revised paper through the conference system.' if status == 'revision' else ''}

Best regards,
GIIR Conference Team
"""
    
    send_email(email, subject, body)

@app.route('/admin/announcements', methods=['GET'])
@login_required
@admin_required
def admin_announcements():
    try:
        # Get all announcements from Firebase
        announcements_ref = db.reference('announcements')
        announcements = announcements_ref.get() or {}
        
        # Sort announcements by pinned status and date
        sorted_announcements = dict(sorted(
            announcements.items(),
            key=lambda x: (
                not x[1].get('is_pinned', False),  # Pinned first
                x[1].get('scheduled_date', ''),    # Then by date
                x[1].get('scheduled_time', '')     # Then by time
            ),
            reverse=True
        ))
        
        return render_template(
            'admin/announcements.html', 
            announcements=sorted_announcements,
            site_design=get_site_design()
        )
    except Exception as e:
        flash(f'Error loading announcements: {str(e)}', 'error')
        return render_template(
            'admin/announcements.html', 
            announcements={},
            site_design=get_site_design()
        )

def send_email(recipients, subject, body, attachments=None):
    """Send email using configured email settings"""
    try:
        # Get email settings from Firebase
        settings_ref = db.reference('email_settings')
        settings = settings_ref.get()
        
        if not settings:
            raise Exception("Email settings not configured")
        
        # Configure Flask-Mail with settings
        app.config.update(
            MAIL_SERVER=settings.get('smtp_host'),
            MAIL_PORT=settings.get('smtp_port'),
            MAIL_USE_TLS=settings.get('use_tls', True),
            MAIL_USE_SSL=settings.get('use_ssl', False),
            MAIL_USERNAME=settings.get('email'),
            MAIL_PASSWORD=settings.get('password'),
            MAIL_DEFAULT_SENDER=f"GIIR Conference <{settings.get('email')}>"
        )
        
        # Create new Mail instance with current config
        mail = Mail(app)
        
        # Create message
        msg = Message(
            subject=subject,
            recipients=recipients if isinstance(recipients, list) else [recipients],
            body=body
        )
        
        # Add attachments if any
        if attachments:
            for attachment in attachments:
                msg.attach(
                    filename=os.path.basename(attachment['path']),
                    content_type=attachment['type'],
                    data=attachment['data']
                )
        
        # Send email
        with app.app_context():
            mail.send(msg)
        return True
    except Exception as e:
        print(f"Error sending email: {str(e)}")
        raise

@app.route('/admin/announcements', methods=['POST'])
@login_required
@admin_required
def create_announcement():
    try:
        print("Creating new announcement...")
        
        # Create announcements upload directory if it doesn't exist
        upload_path = os.path.join(app.static_folder, 'uploads', 'announcements')
        os.makedirs(upload_path, exist_ok=True)
        
        # Get form data
        title = request.form.get('title')
        content = request.form.get('content')
        announcement_type = request.form.get('type')
        is_pinned = request.form.get('is_pinned') == 'on'
        should_send_email = request.form.get('send_email') == 'on'  # Renamed variable
        scheduled_date = request.form.get('announcement_date')
        scheduled_time = request.form.get('announcement_time')
        timezone = request.form.get('timezone')
        
        print("Received form data:", {
            'title': title,
            'content': content[:100] + '...' if content else None,
            'type': announcement_type,
            'is_pinned': is_pinned,
            'send_email': should_send_email,
            'date': scheduled_date,
            'time': scheduled_time,
            'timezone': timezone
        })
        
        if not all([title, content, announcement_type, scheduled_date, scheduled_time, timezone]):
            missing_fields = [field for field, value in {
                'title': title,
                'content': content,
                'type': announcement_type,
                'date': scheduled_date,
                'time': scheduled_time,
                'timezone': timezone
            }.items() if not value]
            error_msg = f"Missing required fields: {', '.join(missing_fields)}"
            print("Error:", error_msg)
            return jsonify({'success': False, 'error': error_msg}), 400
        
        # Handle image upload
        image_url = None
        image_data = None
        if 'image' in request.files:
            file = request.files['image']
            if file and file.filename and allowed_image_file(file.filename):
                filename = secure_filename(file.filename)
                unique_filename = f"announcement_{datetime.now().strftime('%Y%m%d_%H%M%S')}_{filename}"
                file_path = os.path.join(upload_path, unique_filename)
                file.save(file_path)
                image_url = f"/static/uploads/announcements/{unique_filename}"
                print("Image saved:", image_url)
                # Store image data for email attachment
                with open(file_path, 'rb') as f:
                    image_data = f.read()
        
        # Format the datetime with timezone
        formatted_datetime = format_datetime_with_timezone(
            scheduled_date,
            scheduled_time,
            timezone
        )
        
        # Create announcement data
        announcement = {
            'title': title,
            'content': content,
            'type': announcement_type,
            'is_pinned': is_pinned,
            'image_url': image_url,
            'scheduled_date': scheduled_date,
            'scheduled_time': scheduled_time,
            'timezone': timezone,
            'formatted_datetime': formatted_datetime,
            'created_at': datetime.now().isoformat(),
            'created_by': current_user.email,
            'updated_at': datetime.now().isoformat()
        }
        
        print("Saving announcement to Firebase...")
        
        # Save to Firebase
        announcements_ref = db.reference('announcements')
        new_announcement = announcements_ref.push(announcement)
        
        print("Announcement saved successfully with ID:", new_announcement.key)
        
        # Send email notification if requested
        email_status = None
        if should_send_email:  # Using renamed variable
            try:
                print("Sending email notifications...")
                # Get all user emails
                users_ref = db.reference('users')
                users = users_ref.get()
                if users:
                    recipient_emails = [user['email'] for user in users.values() if user.get('email')]
                    print(f"Sending email to {len(recipient_emails)} recipients")
                    
                    # Get email template
                    templates_ref = db.reference('email_templates')
                    templates = templates_ref.get() or {}
                    announcement_template = next(
                        (t for t in templates.values() if t.get('name') == 'announcement_notification'),
                        None
                    )
                    
                    if announcement_template:
                        subject = announcement_template['subject'].replace('{{title}}', title)
                        body = announcement_template['body'].replace('{{title}}', title).replace('{{content}}', content)
                    else:
                        subject = f'New Announcement: {title}'
                        body = f'''
                        A new announcement has been posted:
                        
                        {title}
                        
                        {content}
                        
                        Scheduled for: {scheduled_date} at {scheduled_time} ({timezone})
                        
                        Best regards,
                        Conference Team
                        '''
                    
                    attachments = []
                    if image_url and image_data:
                        attachments.append({
                            'path': image_url,
                            'type': 'image/jpeg',
                            'data': image_data
                        })
                    
                    send_email(recipient_emails, subject, body, attachments)
                    email_status = f"Email notifications sent successfully to {len(recipient_emails)} recipients."
                    print(email_status)
                else:
                    email_status = "No users found to send email notifications."
                    print(email_status)
            except Exception as e:
                error_msg = f"Error sending email notification: {str(e)}"
                print("Error:", error_msg)
                email_status = error_msg
        
        # Check if request is AJAX
        is_ajax = request.headers.get('X-Requested-With') == 'XMLHttpRequest'
        
        if is_ajax:
            return jsonify({
                'success': True, 
                'id': new_announcement.key,
                'emailStatus': email_status,
                'redirect': url_for('admin_announcements')
            })
        else:
            flash('Announcement created successfully!', 'success')
            if email_status:
                flash(email_status, 'info')
            return redirect(url_for('admin_announcements'))
            
    except Exception as e:
        error_msg = f"Error creating announcement: {str(e)}"
        print("Error:", error_msg)
        if request.headers.get('X-Requested-With') == 'XMLHttpRequest':
            return jsonify({'success': False, 'error': error_msg}), 500
        else:
            flash(error_msg, 'error')
            return redirect(url_for('admin_announcements'))

@app.route('/admin/announcements/<announcement_id>', methods=['GET'])
@login_required
@admin_required
def get_announcement(announcement_id):
    try:
        announcement_ref = db.reference(f'announcements/{announcement_id}')
        announcement = announcement_ref.get()
        
        if not announcement:
            return jsonify({'success': False, 'error': 'Announcement not found'}), 404
            
        return jsonify({
            'success': True,
            'announcement': announcement
        })
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/admin/announcements/<announcement_id>', methods=['PUT'])
@login_required
@admin_required
def update_announcement(announcement_id):
    try:
        # Get form data
        title = request.form.get('title')
        content = request.form.get('content')
        announcement_type = request.form.get('type')
        is_pinned = request.form.get('is_pinned') == 'on'
        send_email = request.form.get('send_email') == 'on'
        scheduled_date = request.form.get('announcement_date')
        scheduled_time = request.form.get('announcement_time')
        timezone = request.form.get('timezone')
        
        # Update announcement
        announcement_ref = db.reference(f'announcements/{announcement_id}')
        current_announcement = announcement_ref.get()
        
        if not current_announcement:
            return jsonify({'success': False, 'error': 'Announcement not found'}), 404
        
        # Handle image upload
        image_url = current_announcement.get('image_url')
        if 'image' in request.files:
            file = request.files['image']
            if file and file.filename and allowed_image_file(file.filename):
                # Delete old image if exists
                if image_url:
                    old_image_path = os.path.join(app.static_folder, image_url.lstrip('/static/'))
                    if os.path.exists(old_image_path):
                        os.remove(old_image_path)
                
                # Save new image
                filename = secure_filename(file.filename)
                unique_filename = f"announcement_{datetime.now().strftime('%Y%m%d_%H%M%S')}_{filename}"
                upload_path = os.path.join(app.static_folder, 'uploads', 'announcements')
                os.makedirs(upload_path, exist_ok=True)
                file_path = os.path.join(upload_path, unique_filename)
                file.save(file_path)
                image_url = f"/static/uploads/announcements/{unique_filename}"
        
        # Format the datetime with timezone
        formatted_datetime = format_datetime_with_timezone(
            scheduled_date,
            scheduled_time,
            timezone
        )
        
        update_data = {
            'title': title,
            'content': content,
            'type': announcement_type,
            'is_pinned': is_pinned,
            'image_url': image_url,
            'scheduled_date': scheduled_date,
            'scheduled_time': scheduled_time,
            'timezone': timezone,
            'formatted_datetime': formatted_datetime,
            'updated_at': datetime.now().isoformat(),
            'updated_by': current_user.email
        }
        
        announcement_ref.update(update_data)
        
        # Send email notification if requested
        email_status = None
        if send_email:
            try:
                # Get all user emails
                users_ref = db.reference('users')
                users = users_ref.get()
                if users:
                    recipient_emails = [user['email'] for user in users.values() if user.get('email')]
                    
                    msg = Message(
                        f'Announcement Update: {title}',
                        recipients=recipient_emails,
                        body=f'''
                        An announcement has been updated:
                        
                        {title}
                        
                        {content}
                        
                        Scheduled for: {scheduled_date} at {scheduled_time} ({timezone})
                        
                        Best regards,
                        Conference Team
                        '''
                    )
                    
                    # Add image attachment if exists
                    if image_url:
                        with app.open_resource(os.path.join(app.static_folder, image_url.lstrip('/static/'))) as fp:
                            msg.attach(
                                os.path.basename(image_url),
                                'image/jpeg',
                                fp.read()
                            )
                    
                    mail.send(msg)
                    email_status = "Email notifications sent successfully."
            except Exception as e:
                error_msg = f"Error sending email notification: {str(e)}"
                print("Error:", error_msg)
                email_status = error_msg
        
        return jsonify({
            'success': True,
            'emailStatus': email_status
        })
    except Exception as e:
        error_msg = f"Error updating announcement: {str(e)}"
        print("Error:", error_msg)
        return jsonify({'success': False, 'error': error_msg}), 500

@app.route('/admin/announcements/<announcement_id>', methods=['DELETE'])
@login_required
@admin_required
def delete_announcement(announcement_id):
    try:
        # Delete announcement from Firebase
        announcement_ref = db.reference(f'announcements/{announcement_id}')
        announcement = announcement_ref.get()
        
        if not announcement:
            return jsonify({'success': False, 'error': 'Announcement not found'}), 404
        
        # Delete associated image if exists
        if announcement.get('image_url'):
            image_path = os.path.join(app.static_folder, announcement['image_url'].lstrip('/static/'))
            if os.path.exists(image_path):
                os.remove(image_path)
        
        announcement_ref.delete()
        return jsonify({'success': True})
    except Exception as e:
        error_msg = f"Error deleting announcement: {str(e)}"
        print("Error:", error_msg)
        return jsonify({'success': False, 'error': error_msg}), 500

# Conference schedule configuration
SCHEDULE_DAYS = [
    'Day 1 - January 15, 2024',
    'Day 2 - January 16, 2024',
    'Day 3 - January 17, 2024'
]

TRACKS = [
    'Main Hall',
    'Room A',
    'Room B',
    'Room C',
    'Workshop Room'
]

@app.route('/admin/schedule')
@login_required
@admin_required
def admin_schedule():
    try:
        # Get all schedule sessions from Firebase
        schedule_ref = db.reference('schedule')
        schedule = schedule_ref.get()
        
        # Group sessions by day
        grouped_schedule = {}
        if schedule:
            for session_id, session in schedule.items():
                day = session['day']
                if day not in grouped_schedule:
                    grouped_schedule[day] = {}
                grouped_schedule[day][session_id] = session
            
            # Sort sessions within each day by start time
            for day in grouped_schedule:
                grouped_schedule[day] = dict(sorted(
                    grouped_schedule[day].items(),
                    key=lambda x: x[1]['start_time']
                ))

        return render_template('admin/schedule.html', site_design=get_site_design(),
                             schedule=grouped_schedule,
                             schedule_days=SCHEDULE_DAYS,
                             tracks=TRACKS)
    except Exception as e:
        flash(f'Error loading schedule: {str(e)}', 'error')
        return render_template('admin/schedule.html', site_design=get_site_design(),
                             schedule={},
                             schedule_days=SCHEDULE_DAYS,
                             tracks=TRACKS)

@app.route('/admin/schedule', methods=['POST'])
@login_required
@admin_required
def create_session():
    try:
        data = request.get_json()
        
        # Validate required fields
        required_fields = ['day', 'track', 'start_time', 'end_time', 'title', 'type']
        for field in required_fields:
            if not data.get(field):
                return jsonify({'success': False, 'error': f'Missing required field: {field}'}), 400
        
        # Validate time format
        try:
            start_time = datetime.strptime(data['start_time'], '%H:%M').strftime('%H:%M')
            end_time = datetime.strptime(data['end_time'], '%H:%M').strftime('%H:%M')
            if end_time <= start_time:
                return jsonify({'success': False, 'error': 'End time must be after start time'}), 400
        except ValueError:
            return jsonify({'success': False, 'error': 'Invalid time format'}), 400
        
        # Create new session
        session = {
            'day': data['day'],
            'track': data['track'],
            'start_time': start_time,
            'end_time': end_time,
            'title': data['title'],
            'type': data['type'],
            'speakers': data.get('speakers', ''),
            'description': data.get('description', ''),
            'created_at': datetime.now().isoformat(),
            'created_by': current_user.email,
            'updated_at': datetime.now().isoformat()
        }
        
        # Save to Firebase
        schedule_ref = db.reference('schedule')
        new_session = schedule_ref.push(session)
        
        return jsonify({'success': True, 'id': new_session.key})
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/admin/schedule/<session_id>', methods=['PUT'])
@login_required
@admin_required
def update_session(session_id):
    try:
        data = request.get_json()
        
        # Validate required fields
        required_fields = ['day', 'track', 'start_time', 'end_time', 'title', 'type']
        for field in required_fields:
            if not data.get(field):
                return jsonify({'success': False, 'error': f'Missing required field: {field}'}), 400
        
        # Validate time format
        try:
            start_time = datetime.strptime(data['start_time'], '%H:%M').strftime('%H:%M')
            end_time = datetime.strptime(data['end_time'], '%H:%M').strftime('%H:%M')
            if end_time <= start_time:
                return jsonify({'success': False, 'error': 'End time must be after start time'}), 400
        except ValueError:
            return jsonify({'success': False, 'error': 'Invalid time format'}), 400
        
        # Update session
        session_ref = db.reference(f'schedule/{session_id}')
        current_session = session_ref.get()
        
        if not current_session:
            return jsonify({'success': False, 'error': 'Session not found'}), 404
        
        update_data = {
            'day': data['day'],
            'track': data['track'],
            'start_time': start_time,
            'end_time': end_time,
            'title': data['title'],
            'type': data['type'],
            'speakers': data.get('speakers', ''),
            'description': data.get('description', ''),
            'updated_at': datetime.now().isoformat(),
            'updated_by': current_user.email
        }
        
        session_ref.update(update_data)
        return jsonify({'success': True})
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/admin/schedule/<session_id>', methods=['DELETE'])
@login_required
@admin_required
def delete_session(session_id):
    try:
        # Delete session from Firebase
        session_ref = db.reference(f'schedule/{session_id}')
        session = session_ref.get()
        
        if not session:
            return jsonify({'success': False, 'error': 'Session not found'}), 404
        
        session_ref.delete()
        return jsonify({'success': True})
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/admin/email-templates')
@login_required
@admin_required
def admin_email_templates():
    try:
        # Get all email templates from Firebase
        templates_ref = db.reference('email_templates')
        templates = templates_ref.get()
        
        # Sort templates by category and last updated
        if templates:
            sorted_templates = dict(sorted(
                templates.items(),
                key=lambda x: (x[1].get('category', ''), x[1].get('updated_at', '')),
                reverse=True
            ))
        else:
            sorted_templates = {}
            
        return render_template('admin/email_templates.html', site_design=get_site_design(), templates=sorted_templates)
    except Exception as e:
        flash(f'Error loading email templates: {str(e)}', 'error')
        return render_template('admin/email_templates.html', site_design=get_site_design(), templates={})

@app.route('/admin/email-templates', methods=['POST'])
@login_required
@admin_required
def create_email_template():
    try:
        data = request.get_json()
        
        # Validate required fields
        required_fields = ['name', 'category', 'subject', 'body']
        for field in required_fields:
            if not data.get(field):
                return jsonify({'success': False, 'error': f'Missing required field: {field}'}), 400
        
        # Create new template
        template = {
            'name': data['name'],
            'category': data['category'],
            'subject': data['subject'],
            'body': data['body'],
            'created_at': datetime.now().isoformat(),
            'created_by': current_user.email,
            'updated_at': datetime.now().isoformat()
        }
        
        # Save to Firebase
        templates_ref = db.reference('email_templates')
        new_template = templates_ref.push(template)
        
        return jsonify({'success': True, 'id': new_template.key})
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/admin/email-templates/<template_id>', methods=['PUT'])
@login_required
@admin_required
def update_email_template(template_id):
    try:
        data = request.get_json()
        
        # Validate required fields
        required_fields = ['name', 'category', 'subject', 'body']
        for field in required_fields:
            if not data.get(field):
                return jsonify({'success': False, 'error': f'Missing required field: {field}'}), 400
        
        # Update template
        template_ref = db.reference(f'email_templates/{template_id}')
        current_template = template_ref.get()
        
        if not current_template:
            return jsonify({'success': False, 'error': 'Template not found'}), 404
        
        update_data = {
            'name': data['name'],
            'category': data['category'],
            'subject': data['subject'],
            'body': data['body'],
            'updated_at': datetime.now().isoformat(),
            'updated_by': current_user.email
        }
        
        template_ref.update(update_data)
        return jsonify({'success': True})
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/admin/email-templates/<template_id>', methods=['DELETE'])
@login_required
@admin_required
def delete_email_template(template_id):
    try:
        # Delete template from Firebase
        template_ref = db.reference(f'email_templates/{template_id}')
        template = template_ref.get()
        
        if not template:
            return jsonify({'success': False, 'error': 'Template not found'}), 404
        
        template_ref.delete()
        return jsonify({'success': True})
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500

# Helper function to render email with template
def render_email_template(template_id, context):
    try:
        template_ref = db.reference(f'email_templates/{template_id}')
        template = template_ref.get()
        
        if not template:
            return None, None
            
        # Replace variables in subject and body
        subject = template['subject']
        body = template['body']
        
        for key, value in context.items():
            placeholder = '{{' + key + '}}'
            subject = subject.replace(placeholder, str(value))
            body = body.replace(placeholder, str(value))
            
        return subject, body
    except Exception as e:
        print(f"Error rendering email template: {str(e)}")
        return None, None

# Add these helper functions at the top level
def validate_associate_data(name, description, logo_url):
    """Validate associate data fields"""
    if not name or not name.strip():
        raise ValueError("Associate name is required")
    if not description or not description.strip():
        raise ValueError("Associate description is required")
    if not logo_url or not logo_url.strip():
        raise ValueError("Associate logo is required")
    return True

def save_associate_logo(logo_file, existing_logo=None):
    """Save associate logo to Firebase Storage and return the public URL"""
    if not logo_file or not logo_file.filename:
        if existing_logo:
            return existing_logo
        raise ValueError("Logo file is required")
    
    if not allowed_image_file(logo_file.filename):
        raise ValueError("Invalid image format. Allowed formats: PNG, JPG, JPEG, GIF")
    
    try:
        # Initialize Firebase Storage bucket
        bucket = storage.bucket()
                            
        # Generate unique filename
        filename = secure_filename(logo_file.filename)
        unique_filename = f"associates/logos/{datetime.now().strftime('%Y%m%d_%H%M%S')}_{filename}"
        
        # Create a new blob and upload the file
        blob = bucket.blob(unique_filename)
        # Set content type
        content_type = logo_file.content_type or 'image/jpeg'
        blob.content_type = content_type
        
        # Compress image if needed
        img_data = compress_image(logo_file, max_size_kb=500)
        
        # Upload the file
        blob.upload_from_string(
            img_data,
            content_type=content_type
        )
        
        # Make the blob publicly accessible
        blob.make_public()
        
        # Return the public URL
        return blob.public_url
        
    except Exception as e:
        print(f"Error saving logo to Firebase Storage: {str(e)}")
        raise ValueError(f"Error saving logo: {str(e)}")

def process_associates_data(request_form, request_files):
    """Process associates data from the form submission"""
    try:
        print("Received files in process_associates_data:", request_files.keys())
        associates = []
        errors = []
        bucket = storage.bucket()

        # Process existing associates
        existing_ids = request_form.getlist('existing_associate_ids[]')
        existing_logos = request_form.getlist('existing_associate_logos[]')
        
        print(f"Processing {len(existing_ids)} existing associates")
        
        # Check total number of associates (existing + new)
        new_files = request_files.getlist('new_associate_logos')
        total_associates = len(existing_ids) + len(new_files)
        MAX_ASSOCIATES = 10  # Maximum number of associates allowed
        
        if total_associates > MAX_ASSOCIATES:
            raise ValueError(f"Maximum number of associates ({MAX_ASSOCIATES}) exceeded. Please remove some logos before adding new ones.")
        
        # Handle existing associates
        for i, associate_id in enumerate(existing_ids):
            try:
                logo_url = existing_logos[i]
                logo_key = f'associate_logo_{associate_id}'
                
                if logo_key in request_files and request_files[logo_key].filename:
                    # Delete old logo if it exists
                    try:
                        if logo_url and logo_url.startswith('https://'):
                            blob_path = logo_url.split('/o/')[1].split('?')[0]
                            blob_path = blob_path.replace('%2F', '/')
                            blob = bucket.blob(blob_path)
                            if blob.exists():
                                blob.delete()
                                print(f"Successfully deleted old logo: {blob_path}")
                    except Exception as e:
                        print(f"Error deleting old logo: {str(e)}")

                    # Save new logo
                    logo_url = save_associate_logo(request_files[logo_key])
                
                associates.append({
                    'id': associate_id,
                    'logo': logo_url,
                    'name': 'Associate',
                    'description': ''
                })
                
            except Exception as e:
                errors.append(f"Error processing associate {associate_id}: {str(e)}")

        # Process new associate logos from multiple file upload
        if 'new_associate_logos' in request_files:
            new_files = request_files.getlist('new_associate_logos')
            print(f"Processing {len(new_files)} new associate logos")
            
            for file in new_files:
                if file and file.filename:
                    try:
                        logo_url = save_associate_logo(file)
                        associates.append({
                            'id': str(uuid.uuid4()),
                            'logo': logo_url,
                            'name': 'New Associate',
                            'description': ''
                        })
                        print(f"Successfully added new associate logo: {logo_url}")
                    except Exception as e:
                        print(f"Error processing new logo: {str(e)}")
                        errors.append(str(e))

        if errors:
            print("Errors during associate processing:", errors)
            raise Exception('\n'.join(errors))

        print(f"Successfully processed {len(associates)} total associates")
        return associates

    except Exception as e:
        print(f"Error in process_associates_data: {str(e)}")
        raise e

@app.route('/admin/home-content', methods=['GET', 'POST'])
@login_required
@admin_required
def admin_home_content():
    try:
        content_ref = db.reference('home_content')
        
        if request.method == 'POST':
            try:
                # Initialize update_data with default structure
                update_data = {
                    'welcome': {
                        'title': request.form.get('welcome[title]', ''),
                        'subtitle': request.form.get('welcome[subtitle]', ''),
                        'conference_date': request.form.get('welcome[conference_date]', ''),
                        'message': request.form.get('welcome[message]', ''),
                        'subtitle_marquee': 'welcome[subtitle_marquee]' in request.form
                    },
                    'hero': {
                        'images': [],
                        'conference': {
                            'name': request.form.get('conference[name]', ''),
                            'date': request.form.get('conference[date]', ''),
                            'time': request.form.get('conference[time]', ''),
                            'city': request.form.get('conference[city]', ''),
                            'highlights': request.form.get('conference[highlights]', ''),
                            'show_countdown': 'conference[show_countdown]' in request.form
                        }
                    },
                    'vmo': {
                        'vision': request.form.get('vmo[vision]', ''),
                        'mission': request.form.get('vmo[mission]', ''),
                        'objectives': request.form.get('vmo[objectives]', '')
                    },
                    'associates': [],
                    'footer': {
                        'contact_email': request.form.get('footer[contact_email]', ''),
                        'contact_phone': request.form.get('footer[contact_phone]', ''),
                        'address': request.form.get('footer[address]', ''),
                        'copyright': request.form.get('footer[copyright]', ''),
                        'social_media': {
                            'facebook': request.form.get('footer[social_media][facebook]', ''),
                            'twitter': request.form.get('footer[social_media][twitter]', ''),
                            'linkedin': request.form.get('footer[social_media][linkedin]', '')
                        }
                    }
                }

                # Get current content for existing images
                current_content = content_ref.get() or {}
                if 'hero' in current_content and 'images' in current_content['hero']:
                    update_data['hero']['images'] = current_content['hero']['images']

                # Process deleted hero images
                deleted_images = request.form.getlist('deleted_hero_images[]')
                if deleted_images:
                    update_data['hero']['images'] = [
                        img for img in update_data['hero']['images'] 
                        if img['url'] not in deleted_images
                    ]

                # Process new hero images
                if 'hero_images' in request.files:
                    for file in request.files.getlist('hero_images'):
                        if file and file.filename:
                            try:
                                validate_image(file, image_type='hero')
                                bucket = storage.bucket()
                                filename = secure_filename(file.filename)
                                unique_filename = f"hero/images/{datetime.now().strftime('%Y%m%d_%H%M%S')}_{filename}"
                                blob = bucket.blob(unique_filename)
                                content_type = file.content_type or 'image/jpeg'
                                blob.content_type = content_type
                                img_data = compress_image(file, max_size_kb=800)
                                blob.upload_from_string(img_data, content_type=content_type)
                                blob.make_public()
                                update_data['hero']['images'].append({
                                    'url': blob.public_url,
                                    'alt': filename
                                })
                            except Exception as e:
                                print(f"Error processing hero image: {str(e)}")
                                continue

                # Process associates
                existing_ids = request.form.getlist('existing_associate_ids[]')
                existing_logos = request.form.getlist('existing_associate_logos[]')
                
                # Handle existing associates
                for i, associate_id in enumerate(existing_ids):
                    if i < len(existing_logos):
                        update_data['associates'].append({
                            'id': associate_id,
                            'logo': existing_logos[i]
                        })

                # Process new associate logos
                if 'new_associate_logos' in request.files:
                    for file in request.files.getlist('new_associate_logos'):
                        if file and file.filename:
                            try:
                                validate_image(file)
                                bucket = storage.bucket()
                                filename = secure_filename(file.filename)
                                unique_filename = f"associates/logos/{datetime.now().strftime('%Y%m%d_%H%M%S')}_{filename}"
                                blob = bucket.blob(unique_filename)
                                content_type = file.content_type or 'image/jpeg'
                                blob.content_type = content_type
                                img_data = compress_image(file, max_size_kb=500)
                                blob.upload_from_string(img_data, content_type=content_type)
                                blob.make_public()
                                update_data['associates'].append({
                                    'id': str(uuid.uuid4()),
                                    'logo': blob.public_url
                                })
                            except Exception as e:
                                print(f"Error processing associate logo: {str(e)}")
                                continue

                # Save the updated content
                content_ref.set(update_data)
                
                # Check if request wants JSON response
                if request.headers.get('X-Requested-With') == 'XMLHttpRequest':
                    return jsonify({'success': True})
                
                flash('Home content updated successfully!', 'success')
                return redirect(url_for('admin_home_content'))

            except Exception as e:
                print(f"Error updating home content: {str(e)}")
                if request.headers.get('X-Requested-With') == 'XMLHttpRequest':
                    return jsonify({'success': False, 'error': str(e)})
                flash('Error updating home content', 'error')
                return redirect(url_for('admin_home_content'))

        # GET request - render template
        home_content = content_ref.get() or {}
        return render_template('admin/home_content.html', home_content=home_content)

    except Exception as e:
        print(f"Error in admin_home_content: {str(e)}")
        if request.headers.get('X-Requested-With') == 'XMLHttpRequest':
            return jsonify({'success': False, 'error': str(e)})
        flash('Error loading home content', 'error')
        return render_template('admin/home_content.html', home_content={})

# Add to admin_required routes list in base_admin.html
@app.context_processor
def inject_admin_menu():
    admin_menu = [
        {'url': 'admin_dashboard', 'icon': 'tachometer-alt', 'text': 'Dashboard'},
        {'url': 'admin_home_content', 'icon': 'home', 'text': 'Home Content'},
        {'url': 'admin_about_content', 'icon': 'info-circle', 'text': 'About Content'},
        {'url': 'admin_call_for_papers_content', 'icon': 'file-signature', 'text': 'Call for Papers Content'},
        {'url': 'admin_users', 'icon': 'users', 'text': 'Users'},
        {'url': 'admin_registrations', 'icon': 'clipboard-list', 'text': 'Registrations'},
        {'url': 'admin_submissions', 'icon': 'file-alt', 'text': 'Submissions'},  # Changed from admin_papers to admin_submissions
        {'url': 'admin_schedule', 'icon': 'calendar-alt', 'text': 'Schedule'},
        {'url': 'admin_venue', 'icon': 'map-marker-alt', 'text': 'Venue'},
        {'url': 'admin_registration_fees', 'icon': 'dollar-sign', 'text': 'Registration Fees'},
        {'url': 'admin_announcements', 'icon': 'bullhorn', 'text': 'Announcements'},
        {'url': 'admin_downloads', 'icon': 'download', 'text': 'Downloads'},
        {'url': 'admin_author_guidelines', 'icon': 'book', 'text': 'Author Guidelines'},
        {'url': 'admin_contact_email', 'icon': 'envelope', 'text': 'Contact Settings'},
        {'url': 'admin_email_templates', 'icon': 'envelope', 'text': 'Email Templates'},
        {'url': 'admin_email_settings', 'icon': 'envelope-open', 'text': 'Email Settings'},
        {'url': 'admin_design', 'icon': 'palette', 'text': 'Site Design'},
        {'url': 'admin_profile', 'icon': 'user', 'text': 'My Profile'}
    ]
    return dict(admin_menu=admin_menu)

# Add this to ensure session persistence
app.config['SESSION_COOKIE_SECURE'] = True
app.config['SESSION_COOKIE_HTTPONLY'] = True
app.config['PERMANENT_SESSION_LIFETIME'] = timedelta(minutes=60)

@app.before_request
def before_request():
    if current_user.is_authenticated:
        session.permanent = True  # Make session permanent
        app.permanent_session_lifetime = timedelta(minutes=60)

@app.route('/admin/design', methods=['GET', 'POST'])
@login_required
@admin_required
def admin_design():
    if request.method == 'POST':
        try:
            # Handle theme colors
            theme_data = {
                'primary_color': request.form.get('primary_color', DEFAULT_THEME['primary_color']),
                'secondary_color': request.form.get('secondary_color', DEFAULT_THEME['secondary_color']),
                'accent_color': request.form.get('accent_color', DEFAULT_THEME['accent_color']),
                'text_color': request.form.get('text_color', DEFAULT_THEME['text_color']),
                'background_color': request.form.get('background_color', DEFAULT_THEME['background_color']),
                'header_background': request.form.get('header_background', DEFAULT_THEME['header_background']),
                'footer_background': request.form.get('footer_background', DEFAULT_THEME['footer_background']),
                'hero_text_color': request.form.get('hero_text_color', DEFAULT_THEME['hero_text_color']),
                'subtitle_marquee': 'subtitle_marquee' in request.form
            }
            
            # Save theme data to Firebase
            design_ref = db.reference('site_design')
            design_ref.set(theme_data)
            
            flash('Site design updated successfully!', 'success')
            return redirect(url_for('admin_design'))
            
        except Exception as e:
            flash(f'Error updating site design: {str(e)}', 'error')
            return redirect(url_for('admin_design'))
    
    return render_template('admin/design.html', site_design=get_site_design())

@app.route('/downloads')
def downloads():
    try:
        # Get downloads from Firebase
        downloads_ref = db.reference('downloads')
        downloads_data = downloads_ref.get()
        
        # Organize downloads by category
        organized_downloads = {}
        if downloads_data:
            for key, item in downloads_data.items():
                category = item.get('category', 'General')
                if category not in organized_downloads:
                    organized_downloads[category] = []
                
                # Ensure all required fields are present
                download_item = {
                    'title': item.get('title', 'Untitled'),
                    'description': item.get('description', ''),
                    'type': item.get('type', 'file'),
                    'size': item.get('file_size', ''),
                    'url': item.get('file_url', '#')
                }
                organized_downloads[category].append(download_item)
        
        return render_template('user/conference/downloads.html', 
                             downloads=organized_downloads,
                             site_design=get_site_design())
    except Exception as e:
        flash('Error loading downloads.', 'error')
        return render_template('user/conference/downloads.html', 
                             downloads={},
                             site_design=get_site_design())

@app.route('/admin/about-content', methods=['GET', 'POST'])
@login_required
@admin_required
def admin_about_content():
    try:
        if request.method == 'POST':
            # Handle committee member images
            committee = []
            committee_roles = request.form.getlist('committee_roles[]')
            committee_names = request.form.getlist('committee_names[]')
            committee_affiliations = request.form.getlist('committee_affiliations[]')
            committee_expertise = request.form.getlist('committee_expertise[]')
            committee_existing_images = request.form.getlist('committee_existing_images[]')
            
            # Create upload directory if it doesn't exist
            os.makedirs(os.path.join(app.static_folder, 'uploads', 'committee'), exist_ok=True)
            
            for i in range(len(committee_roles)):
                member = {
                    'role': committee_roles[i],
                    'name': committee_names[i],
                    'affiliation': committee_affiliations[i],
                    'expertise': [exp.strip() for exp in committee_expertise[i].split(',') if exp.strip()],
                    'image': committee_existing_images[i] if i < len(committee_existing_images) else ''
                }
                
                # Check for new image upload
                image_key = f'committee_image_{i}'
                if image_key in request.files:
                    file = request.files[image_key]
                    if file and file.filename and allowed_image_file(file.filename):
                        # Generate unique filename
                        filename = secure_filename(file.filename)
                        unique_filename = f"committee_{datetime.now().strftime('%Y%m%d_%H%M%S')}_{i}.{filename.rsplit('.', 1)[1].lower()}"
                        
                        # Save the file
                        file_path = os.path.join(app.static_folder, 'uploads', 'committee', unique_filename)
                        file.save(file_path)
                        
                        # Update member image path
                        member['image'] = f"/static/uploads/committee/{unique_filename}"
                
                committee.append(member)

            about_content = {
                'overview': {
                    'title': request.form.get('overview_title', ''),
                    'description': request.form.get('overview_description', ''),
                    'stats': {
                        'attendees': request.form.get('stats_attendees', '500+'),
                        'countries': request.form.get('stats_countries', '50+'),
                        'papers': request.form.get('stats_papers', '200+'),
                        'speakers': request.form.get('stats_speakers', '30+')
                    }
                },
                'objectives': [
                    {
                        'icon': icon,
                        'title': title,
                        'description': desc
                    }
                    for icon, title, desc in zip(
                        request.form.getlist('objective_icons[]'),
                        request.form.getlist('objective_titles[]'),
                        request.form.getlist('objective_descriptions[]')
                    )
                ],
                'committee': committee,
                'past_conferences': [
                    {
                        'year': year,
                        'location': loc,
                        'highlight': high
                    }
                    for year, loc, high in zip(
                        request.form.getlist('conference_years[]'),
                        request.form.getlist('conference_locations[]'),
                        request.form.getlist('conference_highlights[]')
                    )
                ]
            }
            
            # Save to Firebase
            db.reference('about_content').set(about_content)
            flash('About page content updated successfully!', 'success')
            return redirect(url_for('admin_about_content'))
            
        # Get existing content
        about_content = db.reference('about_content').get() or {
            'overview': {
                'title': 'About GIIR Conference',
                'description': 'The Global Institute on Innovative Research (GIIR) Conference 2024 brings together leading researchers, practitioners, and industry experts from around the world.',
                'stats': {
                    'attendees': '500+',
                    'countries': '50+',
                    'papers': '200+',
                    'speakers': '30+'
                }
            },
            'objectives': [
                {
                    'icon': 'fa-lightbulb',
                    'title': 'Knowledge Exchange',
                    'description': 'Facilitate the exchange of innovative ideas and research findings'
                },
                {
                    'icon': 'fa-users',
                    'title': 'Networking',
                    'description': 'Create opportunities for networking and collaboration'
                },
                {
                    'icon': 'fa-chart-line',
                    'title': 'Research Impact',
                    'description': 'Showcase cutting-edge research and its potential impact'
                }
            ],
            'committee': [
                {
                    'role': 'Conference Chair',
                    'name': 'Prof. Sarah Johnson',
                    'affiliation': 'Stanford University, USA',
                    'expertise': ['Artificial Intelligence', 'Machine Learning'],
                    'image': ''
                }
            ],
            'past_conferences': [
                {
                    'year': '2023',
                    'location': 'Tokyo, Japan',
                    'highlight': '450+ Attendees'
                }
            ]
        }
        
        return render_template('admin/about_content.html', 
                             about_content=about_content,
                             site_design=get_site_design())
        
    except Exception as e:
        flash(f'Error managing about content: {str(e)}', 'error')
        return redirect(url_for('admin_dashboard'))

def get_registration_fees():
    """
    Helper function to fetch registration fees from Firebase.
    Returns a dictionary containing all registration fee information.
    If no fees are set, returns a default structure.
    """
    try:
        # Get registration fees from Firebase
        fees_ref = db.reference('registration_fees')
        fees = fees_ref.get()
        
        if not fees:
            # Return default structure if no fees are set
            return {
                'currency': {
                    'code': 'ZAR',
                    'symbol': 'R'
                },
                'early_bird': {
                    'enabled': False,
                    'deadline': '',
                    'seats': {
                        'total': 100,
                        'remaining': 100,
                        'show_remaining': True
                    },
                    'fees': {
                        'student_author': 0,
                        'regular_author': 0,
                        'physical_delegate': 0,
                        'virtual_delegate': 0,
                        'listener': 0
                    },
                    'benefits': []
                },
                'early': {
                    'deadline': '',
                    'fees': {
                        'student_author': 0,
                        'regular_author': 0,
                        'physical_delegate': 0,
                        'virtual_delegate': 0,
                        'listener': 0
                    },
                    'benefits': []
                },
                'regular': {
                    'deadline': '',
                    'fees': {
                        'student_author': 0,
                        'regular_author': 0,
                        'physical_delegate': 0,
                        'virtual_delegate': 0,
                        'listener': 0
                    },
                    'benefits': []
                },
                'late': {
                    'deadline': '',
                    'fees': {
                        'student_author': 0,
                        'regular_author': 0,
                        'physical_delegate': 0,
                        'virtual_delegate': 0,
                        'listener': 0
                    },
                    'benefits': []
                },
                'additional_items': {
                    'extra_paper': {
                        'enabled': False,
                        'fee': 0,
                        'description': 'Submit an additional paper',
                        'virtual_eligible': True
                    },
                    'workshop': {
                        'enabled': False,
                        'fee': 0,
                        'description': 'Attend the conference workshop',
                        'virtual_eligible': True
                    },
                    'banquet': {
                        'enabled': False,
                        'fee': 0,
                        'description': 'Join the conference banquet',
                        'virtual_eligible': False
                    }
                }
            }
        
        # Ensure the fees structure is correct
        if 'currency' not in fees:
            fees['currency'] = {
                'code': 'ZAR',
                'symbol': 'R'
            }
        
        # Ensure each period has the correct structure
        for period in ['early_bird', 'early', 'regular', 'late']:
            if period in fees:
                if 'fees' not in fees[period]:
                    fees[period]['fees'] = {}
                
                # Ensure all registration types have a fee
                for reg_type in ['student_author', 'regular_author', 'physical_delegate', 'virtual_delegate', 'listener']:
                    if reg_type not in fees[period]['fees']:
                        fees[period]['fees'][reg_type] = 0
                
                # Ensure benefits list exists
                if 'benefits' not in fees[period]:
                    fees[period]['benefits'] = []
                
                # Ensure early bird has seats info
                if period == 'early_bird':
                    if 'seats' not in fees[period]:
                        fees[period]['seats'] = {
                            'total': 100,
                            'remaining': 100,
                            'show_remaining': True
                        }
        
        # Ensure additional items structure is correct
        if 'additional_items' not in fees:
            fees['additional_items'] = {
                'extra_paper': {
                    'enabled': False,
                    'fee': 0,
                    'description': 'Submit an additional paper',
                    'virtual_eligible': True
                },
                'workshop': {
                    'enabled': False,
                    'fee': 0,
                    'description': 'Attend the conference workshop',
                    'virtual_eligible': True
                },
                'banquet': {
                    'enabled': False,
                    'fee': 0,
                    'description': 'Join the conference banquet',
                    'virtual_eligible': False
                }
            }
        else:
            # Ensure each additional item has the correct structure
            for item in ['extra_paper', 'workshop', 'banquet']:
                if item not in fees['additional_items']:
                    fees['additional_items'][item] = {
                        'enabled': False,
                        'fee': 0,
                        'description': '',
                        'virtual_eligible': item != 'banquet'
                    }
                else:
                    if 'virtual_eligible' not in fees['additional_items'][item]:
                        fees['additional_items'][item]['virtual_eligible'] = item != 'banquet'
        
        return fees
    except Exception as e:
        print(f"Error fetching registration fees: {str(e)}")
        return None

def get_current_registration_period():
    """
    Determines the current registration period based on deadlines.
    Returns: 'early_bird', 'regular', 'late', or 'closed'
    """
    try:
        fees = get_registration_fees()
        if not fees:
            return 'closed'

        current_date = datetime.now().date()
        
        # Check Early Bird period
        if fees.get('early_bird', {}).get('enabled'):
            early_bird_deadline = datetime.strptime(fees['early_bird']['deadline'], '%Y-%m-%d').date()
            if current_date <= early_bird_deadline:
                # Check if seats are available
                seats = fees['early_bird'].get('seats', {})
                if seats.get('remaining', 0) > 0:
                    return 'early_bird'
                
        # Check Regular period
        if fees.get('regular', {}).get('deadline'):
            regular_deadline = datetime.strptime(fees['regular']['deadline'], '%Y-%m-%d').date()
            if current_date <= regular_deadline:
                return 'regular'
                
        # Check Late period
        if fees.get('late', {}).get('deadline'):
            late_deadline = datetime.strptime(fees['late']['deadline'], '%Y-%m-%d').date()
            if current_date <= late_deadline:
                return 'late'
        
        return 'closed'
    except Exception as e:
        print(f"Error determining registration period: {str(e)}")
        return 'closed'

def format_currency(amount, currency_info):
    """
    Formats the amount according to currency settings
    """
    try:
        if not amount:
            return "0.00"
            
        symbol = currency_info.get('symbol', 'R')
        position = currency_info.get('position', 'before')
        
        formatted_amount = f"{float(amount):,.2f}"
        
        if position == 'before':
            return f"{symbol} {formatted_amount}"
        else:
            return f"{formatted_amount} {symbol}"
    except Exception as e:
        print(f"Error formatting currency: {str(e)}")
        return str(amount)

def save_payment_proof(file):
    """Save payment proof file to Firebase Storage and return file data"""
    if not file:
        return None
        
    try:
        # Initialize Firebase Storage
        bucket = firebase_admin.storage.bucket()
        
        # Generate unique filename
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        original_filename = secure_filename(file.filename)
        unique_filename = f"payment_proofs/{timestamp}_{original_filename}"
        
        # Create blob and upload file
        blob = bucket.blob(unique_filename)
        blob.upload_from_string(
            file.read(),
            content_type=file.content_type
        )
        
        # Make the file publicly accessible
        blob.make_public()
        
        # Return file data
        return {
            'url': blob.public_url,
            'filename': original_filename,
            'path': unique_filename,
            'type': file.content_type,
            'size': blob.size
        }
    except Exception as e:
        print(f"Error saving payment proof: {str(e)}")
        return None

@app.route('/registration-form', methods=['GET', 'POST'])
@login_required
def registration_form():
    try:
        if request.method == 'GET':
            # Get current registration period and fees
            current_period = get_current_registration_period()
            if current_period == 'closed':
                flash('Registration is currently closed.', 'error')
                return redirect(url_for('home'))
                
            fees = get_registration_fees()
            if not fees:
                flash('Registration fees are not configured.', 'error')
                return redirect(url_for('home'))
            
            return render_template('registration_form.html', 
                                fees=fees,
                                site_design=get_site_design())
        
        # POST request - process registration
        registration_data = {
            'full_name': current_user.full_name,
            'email': current_user.email,
            'user_id': current_user.id,
            'registration_period': request.form.get('selected_period'),
            'registration_type': request.form.get('selected_type'),
            'total_amount': float(request.form.get('total_amount', 0)),
                'payment_reference': request.form.get('payment_reference'),
                'submission_date': datetime.now().isoformat(),
                'payment_status': 'pending',
                'created_at': datetime.now().isoformat(),
                'updated_at': datetime.now().isoformat()
            }
            
        # Validate registration period
        current_period = get_current_registration_period()
        if current_period == 'closed':
            raise ValueError('Registration is currently closed')
        if registration_data['registration_period'] != current_period:
            raise ValueError('Invalid registration period selected')
            
        # Add additional items if selected
        additional_items = {}
        for item in ['extra_paper', 'workshop', 'banquet']:
            if request.form.get(item) == 'true':
                if not fees['additional_items'][item]['enabled']:
                    raise ValueError(f'{item.replace("_", " ").title()} is not available')
                    
                # Check if virtual delegate is eligible for this item
                if (registration_data['registration_type'] == 'virtual_delegate' and 
                    not fees['additional_items'][item].get('virtual_eligible', True)):
                    raise ValueError(f'{item.replace("_", " ").title()} is not available for virtual delegates')
                    
                additional_items[item] = {
                    'selected': True,
                    'fee': fees['additional_items'][item]['fee']
                }
        
        registration_data['additional_items'] = additional_items
        
        # Handle payment proof file
        payment_proof = request.files.get('payment_proof')
        if payment_proof:
            file_data = save_payment_proof(payment_proof)
            if file_data:
                registration_data['payment_proof'] = file_data
            else:
                raise ValueError('Failed to save payment proof file')
        else:
            raise ValueError('Payment proof is required')
        
        # Update early bird seats if applicable
        if current_period == 'early_bird':
            fees_ref = db.reference('registration_fees/early_bird/seats')
            remaining = fees_ref.child('remaining').get() or 0
            if remaining <= 0:
                raise ValueError('No early bird seats remaining')
            fees_ref.update({
                'remaining': remaining - 1
            })
        
        # Save registration to Firebase Realtime Database
            registrations_ref = db.reference('registrations')
            new_registration = registrations_ref.push(registration_data)
            
        # Save reference to user's registrations collection
            user_reg_ref = db.reference(f'users/{current_user.id}/registrations/{new_registration.key}')
            user_reg_ref.set(True)
            
        # Send confirmation email
        try:
            send_confirmation_email(registration_data)
        except Exception as e:
            print(f"Error sending confirmation email: {str(e)}")
        
            flash('Registration submitted successfully!', 'success')
            return redirect(url_for('dashboard'))
            
    except ValueError as e:
        flash(str(e), 'error')
        return redirect(url_for('registration'))
    except Exception as e:
        flash(f'Error submitting registration: {str(e)}', 'error')
        return redirect(url_for('registration'))

@app.route('/admin/author-guidelines', methods=['GET', 'POST'])
@login_required
@admin_required
def admin_author_guidelines():
    try:
        # Get existing guidelines from Firebase
        guidelines_ref = db.reference('author_guidelines')
        guidelines = guidelines_ref.get()

        if request.method == 'POST':
            # Update guidelines
            new_guidelines = {
                'abstract_guidelines': request.form.get('abstract_guidelines', ''),
                'paper_guidelines': request.form.get('paper_guidelines', ''),
                'oral_guidelines': request.form.get('oral_guidelines', ''),
                'virtual_guidelines': request.form.get('virtual_guidelines', '')
            }

            # Handle template file uploads
            if 'abstract_template' in request.files:
                file = request.files['abstract_template']
                if file and file.filename and allowed_file(file.filename):
                    filename = secure_filename(file.filename)
                    unique_filename = f"abstract_template_{datetime.now().strftime('%Y%m%d_%H%M%S')}_{filename}"
                    upload_path = os.path.join(app.static_folder, 'uploads', 'templates')
                    os.makedirs(upload_path, exist_ok=True)
                    file.save(os.path.join(upload_path, unique_filename))
                    new_guidelines['abstract_template'] = f"/static/uploads/templates/{unique_filename}"

            if 'paper_template' in request.files:
                file = request.files['paper_template']
                if file and file.filename and allowed_file(file.filename):
                    filename = secure_filename(file.filename)
                    unique_filename = f"paper_template_{datetime.now().strftime('%Y%m%d_%H%M%S')}_{filename}"
                    upload_path = os.path.join(app.static_folder, 'uploads', 'templates')
                    os.makedirs(upload_path, exist_ok=True)
                    file.save(os.path.join(upload_path, unique_filename))
                    new_guidelines['paper_template'] = f"/static/uploads/templates/{unique_filename}"

            # Preserve existing template files if no new ones were uploaded
            if guidelines:
                if 'abstract_template' in guidelines and 'abstract_template' not in new_guidelines:
                    new_guidelines['abstract_template'] = guidelines['abstract_template']
                if 'paper_template' in guidelines and 'paper_template' not in new_guidelines:
                    new_guidelines['paper_template'] = guidelines['paper_template']

            # Save to Firebase
            guidelines_ref.set(new_guidelines)
            flash('Author guidelines updated successfully!', 'success')
            return redirect(url_for('admin_author_guidelines'))

        return render_template('admin/author_guidelines.html', 
                            guidelines=guidelines,
                            site_design=get_site_design())

    except Exception as e:
        flash(f'Error managing author guidelines: {str(e)}', 'error')
        return redirect(url_for('admin_dashboard'))

@app.route('/uploads/<path:filename>')
def serve_upload(filename):
    try:
        # Security check - prevent directory traversal
        if '..' in filename or filename.startswith('/'):
            return "Access denied", 403
            
        # Split the path to get the upload type (payments, papers, etc.)
        path_parts = filename.split('/')
        if len(path_parts) < 2:
            return "Invalid path", 400
            
        upload_type = path_parts[0]  # e.g., 'payments', 'papers'
        file_name = path_parts[-1]   # the actual filename
        
        # Validate upload type
        valid_upload_types = {'payments', 'papers', 'documents', 'templates', 'hero', 'committee', 'supporters'}
        if upload_type not in valid_upload_types:
            return "Invalid upload type", 400
        
        # Construct the full path relative to static/uploads
        upload_path = os.path.join(app.static_folder, 'uploads', upload_type)
        file_path = os.path.join(upload_path, file_name)
        
        # Security check - ensure file is within allowed directory
        real_path = os.path.realpath(file_path)
        if not real_path.startswith(os.path.realpath(upload_path)):
            return "Access denied", 403
        
        # Check if file exists
        if not os.path.exists(file_path):
            return "File not found", 404
            
        # Set content disposition to force download for certain file types
        download_types = {'.pdf', '.doc', '.docx', '.xls', '.xlsx', '.zip'}
        _, ext = os.path.splitext(file_name)
        download = ext.lower() in download_types
        
        return send_from_directory(
            upload_path, 
            file_name,
            as_attachment=download,
            download_name=file_name if download else None
        )
        
    except Exception as e:
        print(f"Error serving file: {str(e)}")
        return "Error accessing file", 500

# Admin paper management routes
@app.route('/admin/submissions')
@login_required
@admin_required
def admin_submissions():
    try:
        # Get all papers from Firebase
        papers_ref = db.reference('papers')
        papers = papers_ref.get() or {}
        
        # Sort papers by submission date (newest first)
        sorted_papers = dict(sorted(
            papers.items(),
            key=lambda x: x[1].get('submitted_at', ''),
            reverse=True
        ))
        
        print("Fetched papers:", sorted_papers)  # Debug print
        
        return render_template(
            'admin/submissions.html',
            submissions=sorted_papers,
            site_design=get_site_design()
        )
    except Exception as e:
        print(f"Error loading submissions: {str(e)}")
        flash(f'Error loading submissions: {str(e)}', 'error')
        return render_template(
            'admin/submissions.html',
            submissions={},
            site_design=get_site_design()
        )

@app.route('/admin/papers/<paper_id>/status', methods=['POST'])
@login_required
@admin_required
def update_paper_status(paper_id):
    try:
        data = request.get_json()
        new_status = data.get('status')
        comments = data.get('comments', '')
        
        if new_status not in ['accepted', 'rejected', 'revision']:
            return jsonify({'success': False, 'error': 'Invalid status'}), 400
            
        if not comments.strip() and new_status in ['rejected', 'revision']:
            return jsonify({'success': False, 'error': 'Comments are required for rejection or revision'}), 400
        
        # Update paper status in Firebase
        paper_ref = db.reference(f'papers/{paper_id}')
        paper = paper_ref.get()
        
        if not paper:
            return jsonify({'success': False, 'error': 'Paper not found'}), 404
        
        # Update the paper data
        update_data = {
            'status': new_status,
            'review_comments': comments,
            'updated_at': datetime.now().isoformat(),
            'reviewed_by': current_user.email
        }
        
        paper_ref.update(update_data)
        
        # Get updated paper data for email
        updated_paper = paper_ref.get()
        
        # Send email notification
        try:
            email_service.send_paper_status_update(updated_paper, new_status, comments)
        except Exception as e:
            print(f"Error sending email notification: {str(e)}")
            # Continue even if email fails
        
        return jsonify({
            'success': True,
            'paper': updated_paper
        })
        
    except Exception as e:
        print(f"Error updating paper status: {str(e)}")
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/admin/papers/<paper_id>/comments', methods=['POST'])
@login_required
@admin_required
def save_paper_comments(paper_id):
    try:
        data = request.get_json()
        comments = data.get('comments', '')
        
        # Update paper comments in Firebase
        paper_ref = db.reference(f'papers/{paper_id}')
        paper = paper_ref.get()
        
        if not paper:
            return jsonify({'success': False, 'error': 'Paper not found'}), 404
        
        # Update the comments and metadata
        update_data = {
            'review_comments': comments,
            'updated_at': datetime.now().isoformat(),
            'reviewed_by': current_user.email
        }
        
        paper_ref.update(update_data)
        
        return jsonify({
            'success': True,
            'paper': paper_ref.get()
        })
        
    except Exception as e:
        print(f"Error saving paper comments: {str(e)}")
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/test-email')
def test_email():
    try:
        # Test SMTP connection first
        with mail.connect() as conn:
            print("SMTP Connection successful!")
            
        msg = Message('Test Email from GIIR Conference',
                     sender=app.config['MAIL_DEFAULT_SENDER'],
                     recipients=['thobanisgabuzam@gmail.com'])
        msg.body = '''
        Dear Thobani,
        
        This is a test email from the GIIR Conference system using Outlook SMTP.
        
        If you received this email, it means the email configuration is working correctly.
        
        Best regards,
        GIIR Conference Team
        '''
        
        # Print debug information
        print("\nSMTP Settings:")
        print(f"Server: {app.config['MAIL_SERVER']}")
        print(f"Port: {app.config['MAIL_PORT']}")
        print(f"TLS: {app.config['MAIL_USE_TLS']}")
        print(f"SSL: {app.config['MAIL_USE_SSL']}")
        print(f"Username: {app.config['MAIL_USERNAME']}")
        print(f"Sender: {app.config['MAIL_DEFAULT_SENDER']}")
        
        mail.send(msg)
        return 'Email sent successfully! Check your inbox at thobansigabuzam@gmail.com'
    except Exception as e:
        error_msg = f'Error sending email: {str(e)}\n'
        error_msg += f'Type: {type(e).__name__}\n'
        if hasattr(e, 'strerror'):
            error_msg += f'System error: {e.strerror}\n'
        if hasattr(e, 'errno'):
            error_msg += f'Error number: {e.errno}\n'
        
        # Add network diagnostic info
        try:
            import socket
            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            s.settimeout(5)
            result = s.connect_ex((app.config['MAIL_SERVER'], app.config['MAIL_PORT']))
            error_msg += f'\nPort check result: {result} (0 means port is open)\n'
            s.close()
        except Exception as net_e:
            error_msg += f'\nNetwork test failed: {str(net_e)}\n'
            
        print(error_msg)  # Print to console for debugging
        return error_msg

@app.route('/forgot-password', methods=['GET', 'POST'])
def forgot_password():
    app.logger.debug('Accessing forgot password route')
    try:
        if request.method == 'POST':
            email = request.form.get('email')
            if not email:
                flash('Please enter your email address.', 'error')
                return render_template('user/auth/forgot_password.html', site_design=get_site_design())

            # Check if user exists
            try:
                user = auth.get_user_by_email(email)
            except:
                # Don't reveal if email exists or not for security
                flash('If an account exists with this email, you will receive password reset instructions.', 'info')
                return render_template('user/auth/forgot_password.html', site_design=get_site_design())

            # Generate password reset link
            reset_link = auth.generate_password_reset_link(email)

            # Get user data from database
            user_ref = db.reference(f'users/{user.uid}')
            user_data = user_ref.get()

            if user_data:
                # Send password reset email
                email_service.send_password_reset_email(user_data, reset_link)
                flash('Password reset instructions have been sent to your email.', 'success')
            else:
                flash('Error retrieving user data.', 'error')

            return redirect(url_for('login'))

        return render_template('user/auth/forgot_password.html', site_design=get_site_design())
    except Exception as e:
        app.logger.error(f'Error in forgot_password route: {str(e)}')
        raise

@app.route('/reset-password', methods=['GET', 'POST'])
def reset_password():
    # Handle the actual password reset after user clicks email link
    try:
        mode = request.args.get('mode')
        oobCode = request.args.get('oobCode')
        
        if mode != 'resetPassword' or not oobCode:
            flash('Invalid password reset link.', 'error')
            return redirect(url_for('login'))

        if request.method == 'POST':
            new_password = request.form.get('password')
            confirm_password = request.form.get('confirm_password')

            if new_password != confirm_password:
                flash('Passwords do not match.', 'error')
                return render_template('user/auth/reset_password.html', 
                                    oobCode=oobCode,
                                    site_design=get_site_design())

            # Verify and update password
            try:
                auth.verify_password_reset_code(oobCode)
                auth.confirm_password_reset(oobCode, new_password)
                flash('Password has been reset successfully. Please login with your new password.', 'success')
                return redirect(url_for('login'))
            except Exception as e:
                flash('Error resetting password. The link may have expired.', 'error')
                return redirect(url_for('forgot_password'))

        return render_template('user/auth/reset_password.html', 
                             oobCode=oobCode,
                             site_design=get_site_design())

    except Exception as e:
        flash(f'Error processing password reset: {str(e)}', 'error')
        return redirect(url_for('login'))

@app.route('/admin/email-settings', methods=['GET', 'POST'])
@login_required
@admin_required
def admin_email_settings():
    try:
        if request.method == 'POST':
            # Get form data
            email_settings = {
                'service_provider': request.form.get('service_provider'),
                'email': request.form.get('email'),
                'password': request.form.get('password'),
                'updated_at': datetime.now().isoformat(),
                'updated_by': current_user.email
            }

            # Add SMTP settings if custom provider
            if email_settings['service_provider'] == 'custom':
                email_settings.update({
                    'smtp_host': request.form.get('smtp_host'),
                    'smtp_port': request.form.get('smtp_port'),
                    'use_tls': request.form.get('use_tls') == 'on'
                })
            else:
                # Set default SMTP settings based on provider
                provider_settings = {
                    'outlook': {
                        'smtp_host': 'smtp.office365.com',
                        'smtp_port': 587,
                        'use_tls': True
                    },
                    'zoho': {
                        'smtp_host': 'smtp.zoho.com',
                        'smtp_port': 587,
                        'use_tls': True
                    },
                    'gmail': {
                        'smtp_host': 'smtp.gmail.com',
                        'smtp_port': 587,
                        'use_tls': True
                    }
                }
                email_settings.update(provider_settings.get(email_settings['service_provider'], {}))

            # Save settings to Firebase
            settings_ref = db.reference('email_settings')
            settings_ref.set(email_settings)

            # Update Flask-Mail config
            app.config.update(
                MAIL_SERVER=email_settings['smtp_host'],
                MAIL_PORT=email_settings['smtp_port'],
                MAIL_USE_TLS=email_settings['use_tls'],
                MAIL_USERNAME=email_settings['email'],
                MAIL_PASSWORD=email_settings['password'],
                MAIL_DEFAULT_SENDER=email_settings['email']
            )

            # Reinitialize Flask-Mail with new settings
            global mail
            mail = Mail(app)
            global email_service
            email_service = EmailService(mail)

            flash('Email settings updated successfully!', 'success')
            return redirect(url_for('admin_email_settings'))

        # Get current settings
        settings_ref = db.reference('email_settings')
        settings = settings_ref.get()

        return render_template('admin/email_settings.html', 
                             settings=settings,
                             site_design=get_site_design())
    except Exception as e:
        flash(f'Error managing email settings: {str(e)}', 'error')
        return redirect(url_for('admin_dashboard'))

@app.route('/admin/test-email-settings', methods=['POST'])
@login_required
@admin_required
def test_email_settings():
    try:
        # Get form data
        service_provider = request.form.get('service_provider')
        email = request.form.get('email')
        password = request.form.get('password')

        # Configure SMTP settings
        if service_provider == 'custom':
            smtp_host = request.form.get('smtp_host')
            smtp_port = int(request.form.get('smtp_port'))
            use_tls = request.form.get('use_tls') == 'on'
        else:
            provider_settings = {
                'outlook': {
                    'smtp_host': 'smtp.office365.com',
                    'smtp_port': 587,
                    'use_tls': True
                },
                'zoho': {
                    'smtp_host': 'smtp.zoho.com',
                    'smtp_port': 587,
                    'use_tls': True
                },
                'gmail': {
                    'smtp_host': 'smtp.gmail.com',
                    'smtp_port': 587,
                    'use_tls': True
                }
            }
            settings = provider_settings.get(service_provider)
            if not settings:
                return jsonify({'success': False, 'error': 'Invalid service provider'})
            smtp_host = settings['smtp_host']
            smtp_port = settings['smtp_port']
            use_tls = settings['use_tls']

        # Create temporary Mail instance with new settings
        test_config = Config()
        test_config.MAIL_SERVER = smtp_host
        test_config.MAIL_PORT = smtp_port
        test_config.MAIL_USE_TLS = use_tls
        test_config.MAIL_USERNAME = email
        test_config.MAIL_PASSWORD = password
        test_config.MAIL_DEFAULT_SENDER = email

        test_app = Flask('test_app')
        test_app.config.from_object(test_config)
        test_mail = Mail(test_app)

        # Try to send a test email
        with test_app.app_context():
            msg = Message(
                'Test Email from GIIR Conference',
                recipients=[email],
                body='This is a test email to verify your email settings.'
            )
            test_mail.send(msg)

        return jsonify({'success': True})
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)})

@app.route('/contact', methods=['GET', 'POST'])
def contact():
    if request.method == 'POST':
        try:
            # Get form data
            name = request.form.get('name')
            email = request.form.get('email')
            subject = request.form.get('subject')
            message = request.form.get('message')

            # Validate required fields
            if not all([name, email, subject, message]):
                flash('Please fill in all required fields.', 'error')
                return redirect(url_for('contact'))

            # Save submission to Firebase
            submission = {
                'name': name,
                'email': email,
                'subject': subject,
                'message': message,
                'submitted_at': datetime.now().isoformat()
            }
            submissions_ref = db.reference('contact_submissions')
            submissions_ref.push(submission)
            
            # Get email settings
            settings_ref = db.reference('contact_email_settings')
            email_settings = settings_ref.get()
            
            if email_settings and email_settings.get('email'):
                # Send notification to admin
                admin_subject = f'New Contact Form Submission: {subject}'
                admin_body = f'''New contact form submission received:

From: {name} <{email}>
Subject: {subject}

Message:
{message}'''
                
                email_service.send_email(
                    to_email=email_settings['email'],
                    subject=admin_subject,
                    body=admin_body
                )
                
                # Send auto-reply if configured
                if email_settings.get('auto_reply'):
                    email_service.send_email(
                        to_email=email,
                        subject='Thank you for contacting us',
                        body=email_settings['auto_reply']
                    )
            
            flash('Your message has been sent successfully!', 'success')
            return redirect(url_for('contact'))

        except Exception as e:
            flash(f'Error sending message: {str(e)}', 'error')
            return redirect(url_for('contact'))
    
    # GET request - load page settings
    try:
        settings_ref = db.reference('contact_page_settings')
        page_settings = settings_ref.get()
    except Exception as e:
        flash(f'Error loading page settings: {str(e)}', 'warning')
        page_settings = None
    
    site_design = get_site_design()
    return render_template('user/contact.html', 
                         page_settings=page_settings,
                         site_design=site_design)

@app.route('/submit', methods=['GET', 'POST'])
@login_required
def submit_paper():
    if request.method == 'GET':
        return render_template('submit.html', site_design=get_site_design())
        
    try:
        # Get form data
        data = request.form.to_dict()
        files = request.files
        
        # Process authors from form data
        authors = []
        author_index = 0
        while True:
            author_name = data.get(f'authors[{author_index}][name]')
            author_email = data.get(f'authors[{author_index}][email]')
            author_institution = data.get(f'authors[{author_index}][institution]')
            
            if not author_name:  # No more authors
                break
                
            if author_name and author_email and author_institution:
                authors.append({
                    'name': author_name,
                    'email': author_email,
                    'institution': author_institution
                })
            author_index += 1
        
        if not authors:
            flash('At least one author is required', 'error')
            return redirect(url_for('submit'))
        
        # Process paper file
        if 'paper_file' not in files:
            flash('Paper file is required', 'error')
            return redirect(url_for('submit'))
            
        paper_file = files['paper_file']
        if not paper_file.filename:
            flash('Paper file is required', 'error')
            return redirect(url_for('submit'))
            
        # Check file type
        allowed_extensions = {'pdf', 'doc', 'docx'}
        if not '.' in paper_file.filename or \
           paper_file.filename.rsplit('.', 1)[1].lower() not in allowed_extensions:
            flash('Invalid file type. Allowed types: PDF, DOC, DOCX', 'error')
            return redirect(url_for('submit'))
        
        # Convert file to base64 for storage in Realtime Database
        file_data = paper_file.read()
        file_base64 = base64.b64encode(file_data).decode('utf-8')
        
        # Create paper submission data
        paper_data = {
            'paper_title': data.get('paper_title'),
            'paper_abstract': data.get('paper_abstract'),
            'research_area': data.get('research_area'),
            'presentation_type': data.get('presentation_type'),
            'keywords': [k.strip() for k in data.get('keywords', '').split(',') if k.strip()],
            'authors': authors,
            'file_data': file_base64,
            'file_name': secure_filename(paper_file.filename),
            'file_type': paper_file.content_type,
            'file_size': len(file_data),
            'status': 'pending',
            'submitted_at': datetime.utcnow().isoformat(),
            'submitted_by': current_user.email,
            'user_id': current_user.id,
            'review_comments': None,
            'reviewed_by': None,
            'updated_at': None
        }
        
        # Debug print
        print("Saving paper data:", {k: v for k, v in paper_data.items() if k != 'file_data'})
        
        # Save to Firebase Realtime Database
        papers_ref = db.reference('papers')
        new_paper = papers_ref.push(paper_data)
        
        # Add reference to user's papers
        user_papers_ref = db.reference(f'users/{current_user.id}/papers/{new_paper.key}')
        user_papers_ref.set(True)
        
        # Send confirmation email
        try:
            send_submission_confirmation_email(
                authors[0]['email'],
                paper_data['paper_title'],
                new_paper.key
            )
        except Exception as e:
            print(f"Error sending confirmation email: {str(e)}")
        
        flash('Paper submitted successfully!', 'success')
        return redirect(url_for('dashboard'))
        
    except Exception as e:
        print(f"Error submitting paper: {str(e)}")
        flash(f'Error submitting paper: {str(e)}', 'error')
        return redirect(url_for('submit'))

def send_submission_confirmation_email(email, paper_title, submission_id):
    subject = 'GIIR Conference Paper Submission Confirmation'
    body = f"""Dear Author,

Thank you for submitting your paper to the GIIR Conference 2024.

Submission Details:
Title: {paper_title}
Submission ID: {submission_id}

Your paper has been received and will be reviewed by our committee. You will be notified of any updates regarding your submission.

Best regards,
GIIR Conference Team
"""
    send_email(email, subject, body)

@app.route('/admin/get-email-settings')
@login_required
@admin_required
def get_email_settings():
    try:
        settings_ref = db.reference('email_settings')
        settings = settings_ref.get()
        
        if not settings:
            return jsonify({
                'success': False,
                'error': 'Email settings not configured'
            })
            
        return jsonify({
            'success': True,
            'sender': settings.get('email', 'GIIR Conference')
        })
    except Exception as e:
        return jsonify({
            'success': False,
            'error': str(e)
        })

def process_hero_images(request):
    """Process hero images from the form submission"""
    try:
        hero_images = []
        bucket = storage.bucket()

        # Get current hero images from database
        content_ref = db.reference('home_content')
        current_content = content_ref.get() or {}
        current_hero_images = current_content.get('hero', {}).get('images', [])

        # Handle deleted images first
        deleted_images = request.form.getlist('deleted_hero_images[]')
        print(f"Processing {len(deleted_images)} deleted hero images")
        
        for image_url in deleted_images:
            try:
                print(f"Deleting hero image: {image_url}")
                # Extract blob path from URL
                blob_path = image_url.split('/o/')[1].split('?')[0]
                blob_path = blob_path.replace('%2F', '/')
                blob = bucket.blob(blob_path)
                if blob.exists():
                    blob.delete()
                    print(f"Successfully deleted hero image: {blob_path}")
            except Exception as e:
                print(f"Error deleting hero image: {str(e)}")

        # Keep existing images that weren't deleted
        for image in current_hero_images:
            if image['url'] not in deleted_images:
                hero_images.append(image)

        # Process new hero images
        if 'hero_images' in request.files:
            files = request.files.getlist('hero_images')
            print(f"Processing {len(files)} new hero images")
            
            for file in files:
                try:
                    if file and file.filename:
                        print(f"Processing hero image: {file.filename}")
                        
                        # Validate image with hero type
                        validate_image(file, image_type='hero')
                        
                        # Generate unique filename
                        original_filename = secure_filename(file.filename)
                        ext = os.path.splitext(original_filename)[1].lower()
                        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
                        unique_id = str(uuid.uuid4())[:8]
                        
                        # Use dedicated path for hero images
                        unique_filename = f"content/hero_images/{timestamp}_{unique_id}{ext}"
                        print(f"Generated unique filename: {unique_filename}")
                        
                        # Create a new blob
                        blob = bucket.blob(unique_filename)
                        
                        # Set content type and metadata
                        content_type = mimetypes.guess_type(original_filename)[0] or 'image/jpeg'
                        blob.content_type = content_type
                        blob.metadata = {
                            'optimized': 'false',
                            'originalName': original_filename,
                            'timestamp': timestamp,
                            'type': 'hero_image'
                        }
                        
                        # Compress image if needed (1MB for hero images)
                        file.seek(0)  # Reset file pointer
                        img_data = compress_image(file, max_size_kb=1000)  # 1MB for hero images
                        
                        # Upload the file with metadata
                        blob.upload_from_string(
                            img_data,
                            content_type=content_type
                        )
                        
                        # Make the blob publicly accessible
                        blob.make_public()
                        
                        # Get the public URL
                        public_url = blob.public_url
                        
                        # Add to hero images list
                        hero_images.append({
                            'url': public_url,
                            'alt': original_filename,
                            'filename': unique_filename
                        })
                        
                        print(f"Successfully uploaded hero image: {public_url}")
                        
                except Exception as e:
                    print(f"Error processing hero image {file.filename}: {str(e)}")
                    continue

        print(f"Final count of hero images: {len(hero_images)}")
        return hero_images

    except Exception as e:
        print(f"Error in process_hero_images: {str(e)}")
        raise e

def process_downloads_data(request):
    """Process and save downloads data from form data"""
    downloads = []
    
    # Create base upload directory if it doesn't exist
    base_upload_path = os.path.join(app.root_path, 'static', 'uploads')
    downloads_upload_path = os.path.join(base_upload_path, 'downloads')
    os.makedirs(downloads_upload_path, exist_ok=True)
    
    # Process existing downloads
    existing_titles = request.form.getlist('download_titles[]')
    existing_descriptions = request.form.getlist('download_descriptions[]')
    existing_files = request.form.getlist('download_existing_files[]')
    
    for i in range(len(existing_titles)):
        if existing_titles[i].strip():  # Only process if title exists
            download_data = {
                'title': existing_titles[i],
                'description': existing_descriptions[i],
                'file_url': existing_files[i] if existing_files[i] else None,
                'file_type': 'pdf',  # Default type
                'file_size': '0 KB'  # Default size
            }
            
            # Handle new file upload for existing download
            file_key = f'download_file_{i}'
            if file_key in request.files:
                file = request.files[file_key]
                if file and file.filename and allowed_file(file.filename):
                    try:
                        filename = secure_filename(file.filename)
                        unique_filename = f"download_{datetime.now().strftime('%Y%m%d_%H%M%S')}_{filename}"
                        file_path = os.path.join(downloads_upload_path, unique_filename)
                        # Save the file
                        file.save(file_path)
                        
                        # Update download data
                        file_size = os.path.getsize(file_path)
                        download_data.update({
                            'file_url': f"/static/uploads/downloads/{unique_filename}",
                            'file_type': filename.rsplit('.', 1)[1].lower(),
                            'file_size': f"{file_size / 1024:.1f} KB"
                        })
                    except Exception as e:
                        print(f"Error saving download file {filename}: {str(e)}")
                        continue
            downloads.append(download_data)
    return downloads

@app.route('/admin/contact-email', methods=['GET', 'POST'])
@login_required
@admin_required
def admin_contact_email():
    if request.method == 'POST':
        try:
            # Get form data
            service_provider = request.form.get('service_provider')
            email = request.form.get('email')
            password = request.form.get('password')
            auto_reply = request.form.get('auto_reply')
            
            settings = {
                'service_provider': service_provider,
                'email': email,
                'password': password,
                'auto_reply': auto_reply,
                'updated_at': datetime.now().isoformat(),
                'updated_by': current_user.email
            }
            
            # Add SMTP settings if custom provider
            if service_provider == 'custom':
                settings.update({
                    'smtp_host': request.form.get('smtp_host'),
                    'smtp_port': request.form.get('smtp_port'),
                    'use_tls': 'use_tls' in request.form
                })
            
            # Save settings to Firebase
            settings_ref = db.reference('contact_email_settings')
            settings_ref.set(settings)
            
            # Update email service configuration
            email_service.update_settings(settings)
            
            flash('Email settings saved successfully!', 'success')
            return redirect(url_for('admin_contact_email'))
            
        except Exception as e:
            flash(f'Error saving email settings: {str(e)}', 'error')
            return redirect(url_for('admin_contact_email'))
    
    try:
        # Get email settings
        settings_ref = db.reference('contact_email_settings')
        email_settings = settings_ref.get()
        
        # Get page settings
        page_settings_ref = db.reference('contact_page_settings')
        page_settings = page_settings_ref.get()
        
        return render_template('admin/contact_email.html', 
                             settings=email_settings,
                             page_settings=page_settings)
                             
    except Exception as e:
        flash(f'Error loading settings: {str(e)}', 'warning')
        return render_template('admin/contact_email.html',
                             settings=None,
                             page_settings=None)

@app.route('/test-contact-email', methods=['POST'])
@login_required
@admin_required
def test_contact_email():
    try:
        # Get contact email settings
        settings_ref = db.reference('contact_email_settings')
        settings = settings_ref.get()
        
        if not settings or not settings.get('email'):
            return jsonify({
                'success': False,
                'error': 'Email settings not configured'
            }), 400
        
        # Send test email
        subject = 'Test Contact Form Email'
        body = f'''This is a test email to verify contact form settings.
        
Email Configuration:
- Service Provider: {settings['service_provider']}
- Email: {settings['email']}
- SMTP Host: {settings.get('smtp_host', 'N/A')}
- SMTP Port: {settings.get('smtp_port', 'N/A')}
- TLS Enabled: {settings.get('use_tls', 'N/A')}

Auto-reply message: {settings['auto_reply']}

If you received this email, your contact form settings are working correctly.'''
        
        email_service.send_email(
            to_email=settings['email'],
            subject=subject,
            body=body
        )
        
        return jsonify({'success': True})
    except Exception as e:
        return jsonify({
            'success': False,
            'error': str(e)
        }), 500

@app.route('/admin/contact-page-settings', methods=['POST'])
@login_required
@admin_required
def admin_contact_page_settings():
    try:
        settings = {
            'title': request.form.get('page_title'),
            'description': request.form.get('page_description'),
            'email': request.form.get('contact_email'),
            'phone': request.form.get('contact_phone'),
            'address': request.form.get('contact_address'),
            'updated_at': datetime.now().isoformat(),
            'updated_by': current_user.email
        }
        
        # Save settings to Firebase
        settings_ref = db.reference('contact_page_settings')
        settings_ref.set(settings)
        
        flash('Contact page settings saved successfully!', 'success')
        return redirect(url_for('admin_contact_email'))
        
    except Exception as e:
        flash(f'Error saving contact page settings: {str(e)}', 'error')
        return redirect(url_for('admin_contact_email'))

@app.route('/admin/registrations/export')
@admin_required
def export_registrations():
    try:
        # Get all registrations from Firebase
        registrations_ref = db.reference('registrations')
        registrations_data = registrations_ref.get()
        
        if not registrations_data:
            return jsonify([])
            
        # Convert to list and add Firebase key as _id
        registrations = []
        for key, data in registrations_data.items():
            registration = data.copy()
            registration['_id'] = key
            
            # Format submission date if it exists
            if 'submission_date' in registration:
                try:
                    # Assuming submission_date is stored as ISO string
                    date_obj = datetime.fromisoformat(registration['submission_date'].replace('Z', '+00:00'))
                    registration['submission_date'] = date_obj.strftime('%Y-%m-%d %H:%M:%S')
                except:
                    registration['submission_date'] = registration['submission_date']
            
            registrations.append(registration)
            
        # Sort by submission date in descending order
        registrations.sort(key=lambda x: x.get('submission_date', ''), reverse=True)
        
        return jsonify(registrations)
        
    except Exception as e:
        app.logger.error(f"Error exporting registrations: {str(e)}")
        return jsonify({'error': 'Failed to export registrations'}), 500

@app.route('/admin/papers/<paper_id>/download')
@login_required
@admin_required
def download_paper(paper_id):
    try:
        # Get paper data from Firebase
        paper_ref = db.reference(f'papers/{paper_id}')
        paper = paper_ref.get()
        
        if not paper:
            flash('Paper not found.', 'error')
            return redirect(url_for('admin_submissions'))
            
        # Get file data from Firebase
        file_data = paper.get('file_data')
        if not file_data:
            flash('Paper file not found.', 'error')
            return redirect(url_for('admin_submissions'))
            
        try:
            # Decode base64 data
            file_bytes = base64.b64decode(file_data)
        except Exception as e:
            print(f"Error decoding file data: {str(e)}")
            flash('Error processing file data.', 'error')
            return redirect(url_for('admin_submissions'))
        
        # Create file-like object
        file_obj = io.BytesIO(file_bytes)
        
        # Generate a clean filename
        original_filename = paper.get('file_name', 'paper.pdf')
        safe_filename = secure_filename(original_filename)
        
        # Get correct mimetype
        mimetype = paper.get('file_type')
        if not mimetype or mimetype == 'application/octet-stream':
            # Try to guess mimetype from filename
            mimetype, _ = mimetypes.guess_type(original_filename)
            if not mimetype:
                mimetype = 'application/pdf'  # Default to PDF
        
        # Log download attempt
        print(f"Downloading paper {paper_id}: {safe_filename} ({mimetype})")
        
        # Send file with proper headers
        response = send_file(
            file_obj,
            mimetype=mimetype,
            as_attachment=True,
            download_name=safe_filename,
            max_age=0  # Prevent caching
        )
        
        # Add security headers
        response.headers['X-Content-Type-Options'] = 'nosniff'
        response.headers['Cache-Control'] = 'no-cache, no-store, must-revalidate'
        
        return response
        
    except Exception as e:
        print(f"Error downloading paper: {str(e)}")
        flash(f'Error downloading paper: {str(e)}', 'error')
        return redirect(url_for('admin_submissions'))

def send_paper_status_notification(email, paper_title, status, comments):
    """Send email notification for paper status update"""
    subject = f"Paper Submission Status Update - {paper_title}"
    
    # Build the message body using string concatenation
    body = "Dear Author,\n\n"
    body += f"Your paper titled '{paper_title}' has been {status}.\n\n"
    if comments:
        body += "Reviewer Comments:\n"
        body += comments + "\n\n"
    body += "Best regards,\nConference Team"
    
    try:
        send_email(email, subject, body)
        return True
    except Exception as e:
        print("Error sending paper status notification:", str(e))
        return False

# Default content for home page
default_content = {
    'welcome': {
        'title': 'Welcome to GIIR',
        'subtitle': 'Global Institute on Innovative Research',
        'conference_date': 'International Conference 2024',
        'message': 'Join us for the premier conference in innovative research'
    },
    'hero': {
        'images': [],
        'conference': {
            'name': 'Global Institute on Innovative Research',
            'date': 'TBA',
            'time': 'TBA',
            'city': 'TBA',
            'highlights': 'Keynote Speakers\nTechnical Sessions\nWorkshops\nNetworking Events'
        }
    },
    'vmo': {
        'vision': 'The Global Institute on Innovative Research (GIIR) is geared towards bringing researchers to share their innovative research findings in the global platform',
        'mission': 'GIIR\'s intention is to initiate, develop and promote research in the fields of Social, Economic, Information Technology, Education and Management Sciences',
        'objectives': 'To provide a world class platform for researchers to share their research findings.\nTo encourage researchers to identify significant research issues.\nTo help in the dissemination of researcher\'s work.'
    },
    'downloads': [],
    'associates': [],
    'footer': {
        'contact_email': '',
        'contact_phone': '',
        'social_media': {
            'facebook': '',
            'twitter': '',
            'linkedin': ''
        },
        'address': '',
        'copyright': '© ' + str(datetime.now().year) + ' Global Institute on Innovative Research. All rights reserved.'
    }
}

@app.context_processor
def inject_year():
    return {'now': datetime.now()}

@app.context_processor
def inject_home_content():
    try:
        # Get home content from Firebase
        content_ref = db.reference('home_content')
        home_content = content_ref.get() or default_content
        return {'home_content': home_content}
    except Exception as e:
        print(f"Error loading home content: {str(e)}")
        return {'home_content': default_content}

@app.route('/admin/call-for-papers-content', methods=['GET', 'POST'])
@login_required
@admin_required
def admin_call_for_papers_content():
    try:
        if request.method == 'POST':
            # Process topics of interest
            topics = []
            topic_titles = request.form.getlist('topic_titles[]')
            
            print(f"DEBUG - Admin CFP POST - Number of topics: {len(topic_titles)}")
            print(f"DEBUG - Admin CFP POST - Topic titles: {topic_titles}")
            
            for i, title in enumerate(topic_titles):
                subtopics = request.form.getlist(f'topic_subtopics[{i}][]')
                print(f"DEBUG - Admin CFP POST - Topic {i}: {title} with {len(subtopics)} subtopics")
                topics.append({
                    'title': title,
                    'subtopics': subtopics
                })
            
            # Process important dates
            important_dates = []
            date_icons = request.form.getlist('date_icons[]')
            date_titles = request.form.getlist('date_titles[]')
            date_values = request.form.getlist('date_values[]')
            date_times = request.form.getlist('date_times[]')
            
            for i in range(len(date_titles)):
                important_dates.append({
                    'icon': date_icons[i] if i < len(date_icons) else '',
                    'title': date_titles[i],
                    'date': date_values[i],
                    'time': date_times[i] if i < len(date_times) else ''
                })
            
            # Process submission guidelines
            submission_guidelines = []
            guideline_titles = request.form.getlist('guideline_titles[]')
            
            for i, title in enumerate(guideline_titles):
                items = request.form.getlist(f'guideline_items[{i}][]')
                # Store items as a proper list field, not using the dict.items method
                submission_guidelines.append({
                    'title': title,
                    'guideline_items': items  # Use guideline_items instead of items for storage
                })
            
            # Process CTA section
            cta = {
                'submit_button_text': request.form.get('submit_button_text', 'Submit Your Paper'),
                'template_button_text': request.form.get('template_button_text', 'Download Template'),
                'template_url': request.form.get('template_url', '#')
            }
            
            # Compile the final data structure
            cfp_content = {
                'topics_intro': request.form.get('topics_intro', 'We invite high-quality original research papers in the following areas (but not limited to):'),
                'topics': topics,
                'important_dates': important_dates,
                'submission_guidelines': submission_guidelines,
                'cta': cta
            }
            
            # Print the final structure before saving
            print(f"DEBUG - Admin CFP POST - Final topics structure: {cfp_content['topics']}")
            
            # Save to Firebase
            db.reference('call_for_papers_content').set(cfp_content)
            flash('Call for Papers content updated successfully!', 'success')
            return redirect(url_for('admin_call_for_papers_content'))
        
        # GET request - load current content
        cfp_content = db.reference('call_for_papers_content').get() or {}
        
        # Set up default values if they don't exist in the fetched data
        if 'cta' not in cfp_content:
            cfp_content['cta'] = {
                'submit_button_text': 'Submit Your Paper',
                'template_button_text': 'Download Template',
                'template_url': '#'
            }
            
        # Ensure other required sections exist
        if 'topics_intro' not in cfp_content:
            cfp_content['topics_intro'] = 'We invite high-quality original research papers in the following areas (but not limited to):'
            
        if 'topics' not in cfp_content:
            cfp_content['topics'] = []
            
        if 'important_dates' not in cfp_content:
            cfp_content['important_dates'] = []
            
        if 'submission_guidelines' not in cfp_content:
            cfp_content['submission_guidelines'] = []
        else:
            # Convert any guideline dictionaries to objects with proper properties to avoid the items() method conflict
            structured_guidelines = []
            for guideline in cfp_content['submission_guidelines']:
                if isinstance(guideline, dict):
                    guideline_obj = {}
                    
                    # Copy all properties except 'items'
                    for key, value in guideline.items():
                        if key != 'items':
                            guideline_obj[key] = value
                    
                    # Handle 'items' property - migrate to guideline_items to avoid conflict
                    # First check for guideline_items then items
                    if 'guideline_items' in guideline and isinstance(guideline['guideline_items'], list):
                        guideline_obj['guideline_items'] = guideline['guideline_items']
                    elif 'items' in guideline and isinstance(guideline['items'], list):
                        guideline_obj['guideline_items'] = guideline['items']
                    else:
                        guideline_obj['guideline_items'] = []
                    
                    structured_guidelines.append(guideline_obj)
                else:
                    # If it's not a dict, create a basic structure
                    structured_guidelines.append({
                        'title': 'Guideline',
                        'guideline_items': []
                    })
                    
            cfp_content['submission_guidelines'] = structured_guidelines
        
        print(f"DEBUG - Admin CFP GET - Topics from database: {cfp_content.get('topics', [])}")
            
        return render_template('admin/call_for_papers_content.html', cfp_content=cfp_content)
    
    except Exception as e:
        flash(f'Error: {str(e)}', 'danger')
        print(f"Error in admin_call_for_papers_content: {str(e)}")
        # Provide complete default structure when error occurs
        default_cfp_content = {
            'topics_intro': 'We invite high-quality original research papers in the following areas (but not limited to):',
            'topics': [],
            'important_dates': [],
            'submission_guidelines': [],
            'cta': {
                'submit_button_text': 'Submit Your Paper',
                'template_button_text': 'Download Template',
                'template_url': '#'
            }
        }
        return render_template('admin/call_for_papers_content.html', cfp_content=default_cfp_content)

@app.route('/profile')
@login_required
def profile():
    return render_template('user/account/profile.html')

@app.route('/admin/profile', methods=['GET', 'POST'])
@login_required
@admin_required
def admin_profile():
    if request.method == 'POST':
        try:
            action = request.form.get('action')
            
            # Handle profile update
            if action == 'update_profile':
                # Get form data
                full_name = request.form.get('full_name')
                
                # Validate data
                if not full_name:
                    flash('Full name is required', 'error')
                    return redirect(url_for('admin_profile'))
                
                # Update user data in Firebase
                user_ref = db.reference(f'users/{current_user.id}')
                user_data = user_ref.get() or {}
                
                # Update fields
                user_data['full_name'] = full_name
                user_data['updated_at'] = datetime.now().isoformat()
                
                # Save changes
                user_ref.update(user_data)
                
                # Update display name in Firebase Auth
                auth.update_user(
                    current_user.id,
                    display_name=full_name
                )
                
                flash('Profile updated successfully', 'success')
                return redirect(url_for('admin_profile'))
                
            # Handle password change
            elif action == 'change_password':
                current_password = request.form.get('current_password')
                new_password = request.form.get('new_password')
                confirm_password = request.form.get('confirm_password')
                
                # Validate passwords
                if not all([current_password, new_password, confirm_password]):
                    flash('All password fields are required', 'error')
                    return redirect(url_for('admin_profile'))
                    
                if new_password != confirm_password:
                    flash('New passwords do not match', 'error')
                    return redirect(url_for('admin_profile'))
                    
                if len(new_password) < 8:
                    flash('Password must be at least 8 characters long', 'error')
                    return redirect(url_for('admin_profile'))
                
                # Since we can't verify the current password directly with Firebase Admin SDK,
                # we'll use a hardcoded check for the admin account for demonstration purposes.
                # In a real-world application, you would use Firebase Authentication REST API 
                # with API key to verify the current password.
                if current_user.email == "admin@giirconference.com" and current_password != "Admin@2024!":
                    flash('Current password is incorrect', 'error')
                    return redirect(url_for('admin_profile'))
                
                # Update password in Firebase Auth
                auth.update_user(
                    current_user.id,
                    password=new_password
                )
                
                flash('Password changed successfully', 'success')
                return redirect(url_for('admin_profile'))
                
        except Exception as e:
            flash(f'Error updating profile: {str(e)}', 'error')
            return redirect(url_for('admin_profile'))
    
    # GET request - fetch current profile data
    try:
        user_ref = db.reference(f'users/{current_user.id}')
        user_data = user_ref.get() or {}
        
        return render_template('admin/profile.html', 
                            user_data=user_data,
                            site_design=get_site_design())
                            
    except Exception as e:
        flash(f'Error loading profile: {str(e)}', 'error')
        return render_template('admin/profile.html', 
                            user_data={},
                            site_design=get_site_design())

if __name__ == '__main__':
    create_admin_user()  # Create admin user when starting the app
    
    # Use the PORT environment variable provided by Render
    port = int(os.environ.get('PORT', 8000))
    
    if os.environ.get('FLASK_ENV') == 'production':
        app.run(host='0.0.0.0', port=port)
    else:
        app.run(debug=True, port=port)